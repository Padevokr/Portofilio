{
    "nav-about": "Chi sono",
    "nav-projects": "Progetti", 
    "nav-contacts": "Contatti",
    "hero-eyebrow": "Pasha", 
    "hero-name": "Sviluppatore di Sistemi Telegram", 
    "hero-btn": "Vedi progetti",
    "hero-tagline": "Costruisco sistemi di automazione stabili e scalabili che risolvono reali problemi di business. Dall'architettura al rilascio.",
    "about-title": 
    "Chi sono", 
    "about-text": "Sono una persona che ritiene importante capire come e perché tutto funziona. Mi interessano i sistemi: tecnici, logici e umani. Non amo il caos e le decisioni casuali, quindi scompongo ogni idea nella sua struttura e la porto a uno stato funzionante e stabile.",
    "about-h-approach": "Approccio", 
    "about-app-1": "Prima l'architettura, poi l'implementazione", 
    "about-app-2": "Analisi dei punti di guasto e scalabilità", 
    "about-app-3": "Un sistema, non una raccolta di funzioni",
    "about-h-prog": "Programmazione", 
    "about-prog-1": "Python, logica asincrona, interfacce web", 
    "about-prog-2": "Automazione, eventi, database", 
    "about-prog-3": "Struttura leggibile e codice estensibile",
    "about-h-tg": "Telegram", 
    "about-tg-1": "Bot come parte di un sistema completo", 
    "about-tg-2": "Bundle: bot + interfaccia web + database", 
    "about-tg-3": "Monitoraggio e controllo in tempo reale",
    "about-h-val": "Valori", 
    "about-val-1": "Onestà e schiettezza", 
    "about-val-2": "Dialogo calmo e professionale", 
    "about-val-3": "Stile curato nel codice e nell'interfaccia",
    "tech-title": "Stack Tecnologico",
    "flow-title": "Come Lavoro",
    "flow-1-title": "Analisi",
    "flow-1-desc": "Comprensione profonda dell'obiettivo.",
    "flow-2-title": "Architettura",
    "flow-2-desc": "Progettazione della logica.",
    "flow-3-title": "Implementazione",
    "flow-3-desc": "Scrittura di codice pulito.",
    "flow-4-title": "Test",
    "flow-4-desc": "Garantire la stabilità.",
    "flow-5-title": "Supporto",
    "flow-5-desc": "Affidabilità a lungo termine.",
    "proj-title": "Progetti", 
    "proj-badge": "1 attivo", 
    "proj-name": "Giveaway Bot & Admin Dashboard", 
    "proj-status": "In sviluppo", 
    "proj-more": "Dettagli", 
    "proj-tech-stack": "Stack: Python, Aiogram, SQLite",
    "proj-desc-1": "Sistema di gestione concorsi automatizzato con pannello admin e analisi.",
    "cont-title": "Contatti",
    "cont-note-text": "Se i pulsanti di contatto non funzionano, trovi qui i miei contatti diretti:",
    "cont-note-gh-label": "GitHub:",
    "cont-note-mail-label": "Gmail:",
    "pa-back": "← Torna ai progetti",
    "pa-eyebrow": "Caso di studio",
    "pa-tagline": "Sistema integrato di gestione degli account Telegram: pannello di amministrazione web, bot automatizzato, controllo degli accessi e analisi in un unico prodotto.",
    "pa-status": "In sviluppo attivo",
    "pa-read-more": "Leggi di più",
    "pa-read-less": "Mostra meno",
    "pa-problem-title": "Problema",
    "pa-problem-text": "Gestire manualmente più account Telegram per i giveaway è inefficiente e soggetto a errori. Gli utenti necessitano di anonimato, mentre gli amministratori di controllo centralizzato e trasparenza senza accesso diretto ai dati sensibili.",
    "pa-solution-title": "Soluzione",
    "pa-solution-text": "Ho costruito un sistema completo composto da un bot Telegram per azioni automatizzate, una dashboard web per la gestione e un database sicuro. Il sistema garantisce una partecipazione sicura ai giveaway fornendo analisi in tempo reale.",
    "pa-arch-text": "Bot → Backend → Database → Admin Panel",
    "pa-features-title": "Funzionalità",
    "pa-feat-1": "Sistema di Ruoli: Controllo accessi granulare per admin e utenti.",
    "pa-feat-2": "Controllo Accessi: Login sicuro e autorizzazione azioni.",
    "pa-feat-3": "Logging: Log dettagliati di tutte le azioni di bot e admin.",
    "pa-feat-4": "Logica di Automazione: Script intelligenti per partecipare ai giveaway.",
    "pa-feat-5": "Monitoraggio: Stato in tempo reale di tutti gli account connessi.",
    "pa-concept-title": "Concetto generale",
    "pa-concept-text": "L'obiettivo principale del sistema è automatizzare la partecipazione degli account ai giveaway, garantire l'anonimato degli utenti e fornire all'amministratore il pieno controllo tramite un'interfaccia web. L'architettura è modulare e scalabile: nuove funzionalità possono essere aggiunte senza riscrivere l'intero codice.",
    "pa-users-title": "Utenti e accesso",
    "pa-admin-h": "Per l'amministratore",
    "pa-admin-li1": "Creazione di utenti con ID, nome e username.",
    "pa-admin-li2": "Assegnazione di ruoli, restrizioni e livelli di accesso.",
    "pa-admin-li3": "Collegamento di uno o più account a un utente.",
    "pa-admin-li4": "Controllo completo delle funzionalità del bot.",
    "pa-user-h": "Per l'utente",
    "pa-user-li1": "L'accesso al bot è disponibile solo dopo l'attivazione tramite il sito.",
    "pa-user-li2": "Gestione di più account sotto un unico ID.",
    "pa-user-li3": "Visualizzazione delle statistiche: partecipazione, tasso di successo, attività.",
    "pa-user-li4": "Flusso di lavoro sicuro con codici e password.",
    "pa-bot-title": "Bot Telegram",
    "pa-bot-li1": "Partecipa automaticamente ai giveaway: iscrizioni, captcha, azioni scriptate.",
    "pa-bot-li2": "Monitora l'attività degli account e mostra le statistiche all'utente.",
    "pa-bot-li3": "Sincronizzato con il sito tramite database: le modifiche nel pannello influenzano immediatamente il bot.",
    "pa-bot-li4": "L'elaborazione asincrona consente di gestire più account contemporaneamente.",
    "pa-bot-li5": "Solo gli account attivi e autorizzati partecipano alle campagne.",
    "pa-db-title": "Database e pannello di amministrazione",
    "pa-db-struct-h": "Struttura del database",
    "pa-db-struct-p": "Utenti, account, statistiche e log. Lo stato viene mantenuto dopo il riavvio; sono disponibili analisi ed esportazione.",
    "pa-db-manage-h": "Gestione",
    "pa-db-manage-p": "Aggiunta, modifica ed eliminazione di utenti/account, controllo delle azioni del bot e dei permessi.",
    "pa-db-ui-h": "Interfaccia",
    "pa-db-ui-p": "Tabelle, schede, filtri, visualizzazione dell'attività, effetti hover e navigazione responsive.",
    "pa-sec-title": "Sicurezza e anonimato",
    "pa-sec-li1": "I dati personali sono nascosti e accessibili solo all'amministratore.",
    "pa-sec-li2": "L'accesso agli account è protetto da codici e password.",
    "pa-sec-li3": "Le azioni del bot e dell'amministratore vengono registrate senza divulgare informazioni private.",
    "pa-sec-li4": "L'architettura modulare riduce il rischio di errori e vulnerabilità.",
    "pa-adv-title": "Vantaggi principali",
    "pa-adv-li1": "Gestione centralizzata di utenti e account.",
    "pa-adv-li2": "Automazione della partecipazione ai giveaway senza attività manuali ripetitive.",
    "pa-adv-li3": "Analisi dettagliate per account e utenti.",
    "pa-adv-li4": "Sicurezza, anonimato e gestione trasparente.",
    "pa-adv-li5": "Facile espansione e integrazione di nuovi moduli.",
    "pa-stack-title": "Stack tecnologico",
    "pa-stack-py": "Logica del bot ed elaborazione lato server",
    "pa-stack-tg": "Interazione con gli utenti",
    "pa-stack-web": "Interfaccia web e UX",
    "pa-stack-db": "Archiviazione di utenti e statistiche",
    "pa-stack-async": "Elaborazione asincrona di più account",
    "pa-gallery-title": "Galleria visiva",
    "pa-gal-cap1": "Dashboard amministratore: accessi, ruoli, controllo delle azioni.",
    "pa-gal-cap2": "Percorso utente: interazione su Telegram e scenari di partecipazione.",
    "pa-gal-cap3": "Infrastruttura: stabilità, archiviazione dei dati e scalabilità.",
    "pa-res-title": "Risultato",
    "pa-res-text": "Non è solo un bot, ma un sistema completo: ogni azione è sotto controllo, ogni account è protetto e l'amministratore vede il quadro completo in tempo reale. La soluzione è adatta per automazione scalabile, sviluppo modulare e gestione trasparente degli account Telegram.",
    "pa-hide-details": "Nascondi dettagli",
    "pa-nav-arch": "Architettura",
    "pa-nav-feat": "Funzionalità",
    "pa-nav-users": "Utenti",
    "pa-nav-bot": "Bot",
    "pa-nav-db": "Database",
    "pa-nav-sec": "Sicurezza",
    "pa-nav-stack": "Stack",
    "pa-nav-gal": "Galleria",
    "pa-nav-res": "Risultato",
    "view-all-projects": "Vai all'elenco dei progetti",




    "python": {
        "tech-page-title": "Python: Un'analisi fondamentale dell'ecosistema",
        "tech-main-desc": "Python è un linguaggio di alto livello che combina un'incredibile leggibilità con potenti funzionalità di basso livello. La sua architettura è costruita attorno alla macchina virtuale CPython, che esegue bytecode compilato, rendendolo uno strumento ideale per l'automazione e lo sviluppo backend.",
        "tech-deep-title": "Architettura e meccanismi interni",
        "tech-card-1-title": "L'ambiente CPython",
        "tech-card-1-text": "Analisi del funzionamento della macchina virtuale, dell'interpretazione del bytecode e dell'architettura basata su stack.",
        "tech-card-2-title": "Gestione delle risorse",
        "tech-card-2-text": "Gestione approfondita della memoria tramite reference counting e garbage collector euristico.",
        "tech-card-3-title": "Asincronicità",
        "tech-card-3-text": "Modello di multitasking cooperativo basato su asyncio per sistemi ad alto carico.",
        "full-sec-1-title": "1. Ciclo di vita del codice: da .py al processore",
        "full-sec-1-text": "Quando esegui uno script, Python lo traduce prima in bytecode — un insieme di istruzioni di basso livello. La macchina virtuale CPython le esegue sequenzialmente, garantendo la compatibilità multipiattaforma. Tuttavia, a differenza di Java, Python interpreta il bytecode dinamicamente, offrendo la flessibilità di modificare i tipi delle variabili in fase di runtime. Questo permette di scrivere codice conciso e facilmente scalabile per qualsiasi esigenza aziendale.",
        "full-sec-2-title": "2. Gestione della memoria e il problema del GIL",
        "full-sec-2-text": "In Python, il meccanismo principale di pulizia della memoria è il Reference Counting: un oggetto viene eliminato quando non ci sono più riferimenti che puntano ad esso. Per i riferimenti ciclici, viene utilizzato un Garbage Collector. Una limitazione cruciale è il Global Interpreter Lock (GIL). Questo mutex protegge la thread-safety dei dati ma limita l'esecuzione parallela del bytecode in thread diversi. Per aggirare questo problema in compiti pesanti, utilizziamo il modulo multiprocessing o l'asincronicità.",
        "full-sec-project-case-title": "3. Applicazione nel progetto: Implementazione e librerie",
        "full-sec-project-case-text": "Come ho già menzionato nella sezione principale del mio portfolio, Python è il mio strumento chiave. In questo progetto, l'ho utilizzato per costruire l'architettura modulare del bot. Per garantire la purezza dei dati, ho applicato la libreria **Pydantic** per la validazione rigorosa degli oggetti in entrata. Tutta la logica di business dei giveaway è stata spostata in servizi asincroni separati, il che ha permesso di isolare l'API Telegram da calcoli pesanti. Inoltre, per il monitoraggio approfondito dello stato del sistema, è stata implementata la libreria **Loguru**, che fornisce una registrazione dettagliata di ogni fase dell'automazione."
    },
    "aiogram": {
        "tech-page-title": "Aiogram: Sviluppo professionale di interfacce Telegram",
        "tech-main-desc": "Aiogram è un framework completamente asincrono costruito su asyncio. Incoraggia lo sviluppatore a scrivere codice pulito, tipizzato e modulare, utilizzando i moderni pattern di sviluppo web.",
        "tech-deep-title": "Componenti di sistema",
        "tech-card-1-title": "Advanced Routing",
        "tech-card-1-text": "Sistema multilivello di filtri e router per la gestione dei flussi di dati.",
        "tech-card-2-title": "Stateful Logic (FSM)",
        "tech-card-2-text": "Implementazione di percorsi utente tramite la persistenza degli stati in Redis o RAM.",
        "tech-card-3-title": "Middlewares",
        "tech-card-3-text": "Livelli di elaborazione intermedia per implementare logiche trasversali (logging, anti-spam).",
        "full-sec-1-title": "1. Gestione degli eventi e Middleware",
        "full-sec-1-text": "In Aiogram, ogni evento (Update) passa attraverso una catena di Middleware. Ciò consente di iniettare logiche prima che il messaggio raggiunga l'handler principale. Ad esempio, puoi verificare automaticamente l'iscrizione dell'utente a un canale o limitare la frequenza delle richieste (Rate limiting). Questo rende il sistema protetto da abusi e consente di spostare la logica comune in livelli separati, senza ingombrare il codice di elaborazione dei comandi.",
        "full-sec-2-title": "2. Macchina a stati finiti (FSM)",
        "full-sec-2-text": "Per creare interfacce complesse, viene utilizzata una Macchina a Stati Finiti. Essa ricorda in quale fase del dialogo si trova l'utente. Per evitare la perdita di dati durante un riavvio del bot, colleghiamo storage esterni (Redis/Postgres). Questo è lo standard per le soluzioni Enterprise, che consente di aggiornare senza problemi il codice del bot, senza interrompere le sessioni utente attive.",
        "full-sec-project-case-title": "Applicazione nel progetto: Meccaniche Telegram",
        "full-sec-project-case-text": "Come ho già menzionato nella pagina principale del mio portfolio, sono specializzato nello sviluppo di sistemi Telegram. In questo progetto, ho utilizzato **Aiogram 3.x** per costruire un'architettura di interazione asincrona. Ho implementato un sistema di **Custom Middlewares** per verificare automaticamente l'iscrizione dell'utente ai canali sponsor prima di consentire l'accesso al giveaway. È stata inoltre implementata una macchina a stati (**FSM**) con storage in **Redis**, che consente agli amministratori di configurare i giveaway passo dopo passo (caricamento media, selezione data, impostazione condizioni) senza perdere i progressi nemmeno durante un riavvio del server. Per proteggere da tentativi di frode, ho integrato filtri personalizzati lato dispatcher che escludono attività sospette dei bot."
    },
    "postgres": {
        "tech-page-title": "PostgreSQL: Database di livello industriale",
        "tech-main-desc": "PostgreSQL è un DBMS relazionale a oggetti, noto per la sua affidabilità, il supporto a query complesse e la rigorosa aderenza agli standard ACID.",
        "tech-deep-title": "Dettagli tecnici",
        "tech-card-1-title": "MVCC",
        "tech-card-1-text": "Il controllo di concorrenza multiversione consente di leggere i dati senza blocchi durante le scritture.",
        "tech-card-2-title": "Conformità ACID",
        "tech-card-2-text": "Garanzia dell'integrità dei dati anche in caso di improvvisi guasti di alimentazione o di sistema.",
        "tech-card-3-title": "Supporto JSONB",
        "tech-card-3-text": "Gestione efficiente di dati non strutturati all'interno di tabelle SQL.",
        "full-sec-1-title": "1. Transazioni e integrità",
        "full-sec-1-text": "Postgres garantisce che ogni operazione venga completata per intero o non venga eseguita affatto (atomicità). Il meccanismo di Write-Ahead Logging (WAL) registra tutte le modifiche in un log prima di applicarle alla tabella. Questo è di fondamentale importanza per i sistemi finanziari o di gioco, dove un errore in un singolo record potrebbe portare alla perdita di consistenza dell'intero database.",
        "full-sec-2-title": "2. Indicizzazione e ricerca",
        "full-sec-2-text": "Utilizziamo non solo i classici indici B-tree, ma anche indici GIN per accelerare la ricerca nei campi JSONB. Ciò consente a Postgres di combinare la velocità delle soluzioni NoSQL con l'affidabilità dei database relazionali classici. Una corretta pianificazione delle query (Explain Analyze) consente di ottimizzare il carico e garantire una risposta istantanea anche su selezioni di milioni di righe.",
        "full-sec-project-case-title": "Applicazione nel progetto: Architettura dei dati",
        "full-sec-project-case-text": "Come ho già menzionato nella pagina principale, utilizzo i database per garantire la massima stabilità dei sistemi. In questo progetto, ho scelto PostgreSQL per la sua estensibilità e affidabilità. Per l'integrazione con il codice asincrono del bot, ho utilizzato **SQLAlchemy** insieme al driver **asyncpg**, che ha permesso al database di funzionare senza bloccare il thread principale. Ho progettato lo schema relazionale in modo che anche con 100.000+ partecipanti, la selezione del vincitore avvenga istantaneamente. Ciò è stato ottenuto impostando indici **B-tree** compositi sui campi ID utente e ID giveaway, garantendo al 100% la consistenza dei dati durante le operazioni di massa."
    },
    "flask": {
        "tech-page-title": "Flask & FastAPI: Interfacce web moderne",
        "tech-main-desc": "Micro-framework per la creazione di logiche lato server e API. Flask viene utilizzato per pannelli di amministrazione flessibili, FastAPI per servizi asincroni ad alte prestazioni con validazione automatica dei dati.",
        "tech-deep-title": "Capacità fondamentali",
        "tech-card-1-title": "Progettazione di microservizi",
        "tech-card-1-text": "Architettura senza codice superfluo: collega solo i moduli necessari per ogni attività.",
        "tech-card-2-title": "Validazione Pydantic",
        "tech-card-2-text": "In FastAPI, i dati vengono automaticamente validati a livello di tipo, eliminando gli errori di richiesta.",
        "tech-card-3-title": "Swagger & OpenAPI",
        "tech-card-3-text": "Documentazione API interattiva automatica disponibile 'pronta all'uso'.",
        "full-sec-1-title": "1. API RESTful e Dependency Injection",
        "full-sec-1-text": "Nella progettazione del backend, aderisco ai principi REST. A ogni risorsa corrisponde un proprio URL e le azioni sono definite dai metodi HTTP standard. FastAPI implementa un potente sistema di dependency injection (DI). Ciò rende facile gestire connessioni al database, autenticazione e impostazioni, rendendo il codice modulare e adatto al testing automatico. Tutto lo scambio di dati avviene in formato JSON, garantendo una compatibilità ideale con qualsiasi framework frontend.",
        "full-sec-2-title": "2. Templating e I/O asincrono",
        "full-sec-2-text": "Per Flask, utilizziamo Jinja2, un motore di template sicuro. Consente la generazione dinamica di HTML lato server, inserendo dati da Python direttamente nel markup. Nel caso di FastAPI, viene utilizzato I/O completamente asincrono. Ciò significa che il server non 'si addormenta' durante una lunga richiesta al database, ma continua a elaborare altre chiamate in arrivo. Questo è di fondamentale importanza per i dashboard di monitoraggio, dove i dati devono essere aggiornati istantaneamente."
    },
    "git": {
        "tech-page-title": "Git: Controllo di versione professionale",
        "tech-main-desc": "Git è un sistema di controllo di versione distribuito che rappresenta lo standard del settore. Consente di salvare una cronologia delle modifiche, lavorare in team e sperimentare in modo sicuro con il codice.",
        "tech-deep-title": "Concetti fondamentali",
        "tech-card-1-title": "Strategia di branching",
        "tech-card-1-text": "Creazione di branch isolati per ogni nuova funzionalità (Sviluppo feature-driven).",
        "tech-card-2-title": "Modello a snapshot",
        "tech-card-2-text": "Git memorizza snapshot completi dello stato del progetto, non le differenze dei file, per affidabilità.",
        "tech-card-3-title": "Commit atomici",
        "tech-card-3-text": "Possibilità di suddividere le modifiche in parti logiche per un facile rollback e analisi.",
        "full-sec-1-title": "1. Struttura interna: Snapshot e hash",
        "full-sec-1-text": "Git è essenzialmente un database a grafo. Ogni commit ha un hash SHA-1 univoco, che garantisce che il contenuto del codice non sia stato alterato inosservato. A differenza dei sistemi più vecchi (SVN), Git memorizza snapshot completi dei file. Ciò rende istantanee operazioni come il cambio di branch (checkout) e il merge. Comprendere concetti come 'indice' (area di staging) e 'albero' mi consente di gestire efficientemente anche i conflitti di merge più complessi.",
        "full-sec-2-title": "2. Metodologia Git Flow",
        "full-sec-2-text": "Per uno sviluppo stabile, utilizzo Git Flow. Il branch principale (main) contiene sempre solo codice testato e pronto per la produzione. Lo sviluppo avviene nel branch 'develop' e ogni nuova funzionalità viene creata in un branch separato 'feature/'. Ciò impedisce al codice non finito di rompere il sistema funzionante. L'uso di comandi come cherry-pick e rebase mi consente di mantenere una cronologia dei commit pulita e comprensibile, il che è fondamentale per la manutenzione a lungo termine del progetto."
    },
    "frontend": {
        "tech-page-title": "HTML / CSS / JS: L'interfaccia visiva",
        "tech-main-desc": "Il trio di tecnologie che modella l'esperienza utente. Utilizziamo standard moderni di markup, styling e scripting per creare applicazioni web veloci e reattive.",
        "tech-deep-title": "Tecnologie fondamentali",
        "tech-card-1-title": "Layout moderni",
        "tech-card-1-text": "Impaginazione con Flexbox e Grid per una visualizzazione perfetta su qualsiasi tipo di dispositivo.",
        "tech-card-2-title": "Standard ES6+",
        "tech-card-2-text": "Utilizzo di asincronicità e moduli in JS per un funzionamento fluido dell'interfaccia.",
        "tech-card-3-title": "Design UX / UI",
        "tech-card-3-text": "Attenzione all'intuitività, all'accessibilità e agli effetti visivi moderni (Glassmorfismo).",
        "full-sec-1-title": "1. DOM e JavaScript asincrono",
        "full-sec-1-text": "Il frontend moderno non è solo pagine statiche. Con JavaScript, manipolo l'albero del DOM (Document Object Model), modificando dinamicamente l'interfaccia in risposta alle azioni dell'utente. L'uso dell'API Fetch consente lo scambio di dati in background con il backend. Questo crea l'effetto di una Single Page Application (SPA), dove la pagina non si ricarica completamente ma aggiorna solo i blocchi di dati necessari, migliorando significativamente il comfort dell'utente.",
        "full-sec-2-title": "2. Architettura CSS e animazioni",
        "full-sec-2-text": "Per lo styling, utilizzo variabili CSS e metodi di posizionamento moderni. Questo rende facile implementare temi chiari e scuri. Le animazioni sono implementate utilizzando l'accelerazione hardware (transform: translate3d), garantendo fluidità a 60 FPS anche su dispositivi mobili. Particolare attenzione è rivolta alla metodologia di layout: separo gli stili in moduli logici in modo che possano essere facilmente riutilizzati in diverse parti del progetto.",
        "full-sec-project-case-title": "Applicazione nel progetto: Interfaccia interattiva",
        "full-sec-project-case-text": "Come ho già menzionato nella pagina principale del mio portfolio, presto grande attenzione non solo al codice ma anche al comfort visivo dell'utente. In questo progetto, ho implementato un pannello di amministrazione reattivo in puro **JavaScript** senza l'uso di framework pesanti, il che ha garantito un caricamento istantaneo. Ho applicato tecniche di layout moderne (Flexbox e CSS Grid) per creare un'interfaccia 'vetro' complessa (Glassmorfismo) che rimane leggibile su qualsiasi dispositivo. Tutta la comunicazione con il backend avviene tramite richieste asincrone **Fetch API**, consentendo all'amministratore di gestire i giveaway e monitorare le statistiche dei partecipanti senza dover ricaricare la pagina."
    },
    "asyncio": {
        "tech-page-title": "Asyncio: Asincronicità profonda in Python",
        "tech-main-desc": "Asyncio è una libreria per scrivere codice concorrente utilizzando la sintassi async/await. È il fondamento per i moderni sistemi ad alto carico che gestiscono migliaia di connessioni di rete simultaneamente.",
        "tech-deep-title": "Concetti di asincronicità",
        "tech-card-1-title": "Event Loop",
        "tech-card-1-text": "Il ciclo centrale che gestisce l'esecuzione di tutte le attività in un singolo thread.",
        "tech-card-2-title": "Coroutines",
        "tech-card-2-text": "Funzioni che possono sospendere il loro lavoro senza bloccare l'intero programma.",
        "tech-card-3-title": "I/O non bloccante",
        "tech-card-3-text": "Il sistema non attende le risposte di rete, passando immediatamente ad altre attività.",
        "full-sec-1-title": "1. Multitasking cooperativo",
        "full-sec-1-text": "A differenza dei thread classici, Asyncio utilizza un modello in cui le coroutine cedono il controllo all'Event Loop. Ciò elimina le race condition per i dati condivisi e consente a un singolo processo di servire un numero colossale di richieste, consumando dieci volte meno RAM. Questo rende Python ideale per microservizi e bot.",
        "full-sec-2-title": "2. Scalabilità delle chiamate di rete",
        "full-sec-2-text": "Asyncio opera su chiamate di sistema di basso livello (epoll/kqueue), permettendogli di monitorare migliaia di socket. Il programma 'dorme' a livello del kernel del sistema operativo fino all'arrivo dei dati. Ciò garantisce che la latenza di una richiesta non influisca sulla velocità effettiva complessiva dell'intero sistema.",
        "full-sec-project-case-title": "Applicazione nel progetto: Multi-account e velocità",
        "full-sec-project-case-text": "**Non ho menzionato Asyncio nella pagina principale**, ma in questo progetto è stata una tecnologia chiave. Ho utilizzato l'asincronicità per implementare il **multi-account** — il bot può lavorare con diverse sessioni Telegram simultaneamente senza interferenze. Utilizzando `asyncio.gather()`, ho configurato controlli paralleli di iscrizione in 5-10 canali contemporaneamente. Ciò ha ridotto il tempo di attesa dell'utente da diversi secondi a millisecondi. Le code asincrone (Tasks) hanno anche garantito invii in background stabili che non rallentano l'interfaccia principale del bot durante i giveaway attivi."
    }
}