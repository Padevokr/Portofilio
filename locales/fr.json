{
    "nav-about": "À propos", 
    "nav-projects": "Projets", 
    "nav-contacts": "Contacts",
    "hero-eyebrow": "Pasha", 
    "hero-name": "Développeur de Systèmes Telegram", 
    "hero-btn": "Voir les projets",
    "hero-tagline": "Je construis des systèmes d'automatisation stables et évolutifs qui résolvent de vrais problèmes commerciaux. De l'architecture au déploiement.",
    "about-title": "À propos de moi", 
    "about-text": "Je suis une personne pour qui il est important de comprendre comment et pourquoi tout fonctionne. Je m'intéresse aux systèmes : techniques, logiques et humains. Je n'aime pas le chaos ni les décisions aléatoires, c'est pourquoi je décompose toute idée dans sa structure pour l'amener à un état fonctionnel et stable.",
    "about-h-approach": "Approche", 
    "about-app-1": "D'abord l'architecture, puis l'implémentation", 
    "about-app-2": "Analyse des points de défaillance et de l'évolutivité", 
    "about-app-3": "Un système, pas une collection de fonctions sans lien",
    "about-h-prog": "Programmation", 
    "about-prog-1": "Python, logique asynchrone, interfaces web", 
    "about-prog-2": "Automatisation, événements, base de données", 
    "about-prog-3": "Structure lisible et code extensible",
    "about-h-tg": "Telegram", 
    "about-tg-1": "Les bots comme partie d'un système complet", 
    "about-tg-2": "Pack : bot + interface web + base de données", 
    "about-tg-3": "Surveillance et contrôle en temps réel",
    "about-h-val": "Valeurs", 
    "about-val-1": "Honnêteté et franchise", 
    "about-val-2": "Dialogue calme et professionnel", 
    "about-val-3": "Style réfléchi dans le code et l'interface",
    "tech-title": "Stack Technique",
    "flow-title": "Ma Méthode",
    "flow-1-title": "Analyse",
    "flow-1-desc": "Compréhension profonde de l'objectif.",
    "flow-2-title": "Architecture",
    "flow-2-desc": "Conception de la logique.",
    "flow-3-title": "Implémentation",
    "flow-3-desc": "Écriture de code propre.",
    "flow-4-title": "Tests",
    "flow-4-desc": "Garantir la stabilité.",
    "flow-5-title": "Support",
    "flow-5-desc": "Fiabilité à long terme.",
    "proj-title": "Projets", 
    "proj-badge": "1 actif", 
    "proj-name": "Bot de concours & Tableau de bord admin", 
    "proj-status": "En développement actif", 
    "proj-more": "Plus de détails", 
    "proj-tech-stack": "Stack : Python, Aiogram, SQLite",
    "proj-desc-1": "Système de gestion de concours automatisé avec panneau d'administration et analytique.",
    "cont-title": "Contacts",
    "cont-note-text": "Si les boutons de contact ne fonctionnent pas sur votre appareil, trouvez ici mes contacts directs:",
    "cont-note-gh-label": "GitHub:",
    "cont-note-mail-label": "Gmail:",
    "pa-back": "← Retour aux projets",
    "pa-eyebrow": "Étude de cas",
    "pa-tagline": "Système intégré de gestion des comptes Telegram : panneau d'administration web, bot automatisé, contrôle d'accès et analytique réunis dans un seul produit.",
    "pa-status": "En développement actif",
    "pa-read-more": "Lire la suite",
    "pa-read-less": "Montrer moins",
    "pa-problem-title": "Problème",
    "pa-problem-text": "Gérer manuellement plusieurs comptes Telegram pour des concours est inefficace et sujet aux erreurs. Les utilisateurs ont besoin d'anonymat, tandis que les administrateurs nécessitent un contrôle centralisé et une transparence sans accès direct aux données sensibles.",
    "pa-solution-title": "Solution",
    "pa-solution-text": "J'ai construit un système complet composé d'un bot Telegram pour les actions automatisées, d'un tableau de bord web pour la gestion et d'une base de données sécurisée. Le système assure une participation sûre aux concours tout en fournissant des analyses en temps réel.",
    "pa-arch-text": "Bot → Backend → Base de données → Panneau Admin",
    "pa-features-title": "Fonctionnalités",
    "pa-feat-1": "Système de Rôles : Contrôle d'accès granulaire pour admins et utilisateurs.",
    "pa-feat-2": "Contrôle d'Accès : Connexion sécurisée et autorisation des actions.",
    "pa-feat-3": "Journalisation : Logs détaillés de toutes les actions du bot et de l'admin.",
    "pa-feat-4": "Logique d'Automatisation : Scripts intelligents pour rejoindre les concours.",
    "pa-feat-5": "Surveillance : Statut en temps réel de tous les comptes connectés.",
    "pa-concept-title": "Concept général",
    "pa-concept-text": "L'objectif principal du système est d'automatiser la participation des comptes aux tirages au sort, de garantir l'anonymat des utilisateurs et d'offrir à l'administrateur un contrôle total via une interface web. L'architecture est modulaire et évolutive : de nouvelles fonctionnalités peuvent être ajoutées sans réécrire l'ensemble du code.",
    "pa-users-title": "Utilisateurs et accès",
    "pa-admin-h": "Pour l'administrateur",
    "pa-admin-li1": "Création d'utilisateurs avec ID, nom et nom d'utilisateur.",
    "pa-admin-li2": "Attribution des rôles, restrictions et niveaux d'accès.",
    "pa-admin-li3": "Association d'un ou plusieurs comptes à un utilisateur.",
    "pa-admin-li4": "Contrôle complet des fonctionnalités du bot.",
    "pa-user-h": "Pour l'utilisateur",
    "pa-user-li1": "L'accès au bot est accordé uniquement après activation via le site.",
    "pa-user-li2": "Gestion de plusieurs comptes sous un même ID.",
    "pa-user-li3": "Consultation des statistiques : participation, taux de réussite, activité.",
    "pa-user-li4": "Processus sécurisé avec codes et mots de passe.",
    "pa-bot-title": "Bot Telegram",
    "pa-bot-li1": "Participe automatiquement aux tirages au sort : abonnements, captchas, actions scriptées.",
    "pa-bot-li2": "Suit l'activité des comptes et affiche les statistiques à l'utilisateur.",
    "pa-bot-li3": "Synchronisé avec le site via la base de données : les modifications du panneau affectent immédiatement le bot.",
    "pa-bot-li4": "Le traitement asynchrone permet de gérer plusieurs comptes simultanément.",
    "pa-bot-li5": "Seuls les comptes actifs et autorisés participent aux campagnes.",
    "pa-db-title": "Base de données et panneau d'administration",
    "pa-db-struct-h": "Structure de la base de données",
    "pa-db-struct-p": "Utilisateurs, comptes, statistiques et journaux. L'état est conservé après redémarrage ; l'analyse et l'export sont disponibles.",
    "pa-db-manage-h": "Gestion",
    "pa-db-manage-p": "Ajout, modification et suppression d'utilisateurs/comptes, gestion des actions du bot et des permissions.",
    "pa-db-ui-h": "Interface",
    "pa-db-ui-p": "Tableaux, cartes, filtres, visualisation de l'activité, effets au survol et navigation adaptative.",
    "pa-sec-title": "Sécurité et anonymat",
    "pa-sec-li1": "Les données personnelles sont masquées et accessibles uniquement à l'administrateur.",
    "pa-sec-li2": "L'accès aux comptes est protégé par des codes et mots de passe.",
    "pa-sec-li3": "Les actions du bot et de l'administrateur sont enregistrées sans divulguer d'informations privées.",
    "pa-sec-li4": "L'architecture modulaire réduit les risques d'erreurs et de vulnérabilités.",
    "pa-adv-title": "Avantages clés",
    "pa-adv-li1": "Gestion centralisée des utilisateurs et des comptes.",
    "pa-adv-li2": "Automatisation de la participation aux tirages au sort sans tâches manuelles répétitives.",
    "pa-adv-li3": "Analytique détaillée par comptes et utilisateurs.",
    "pa-adv-li4": "Sécurité, anonymat et gestion transparente.",
    "pa-adv-li5": "Extension facile et intégration de nouveaux modules.",
    "pa-stack-title": "Stack technologique",
    "pa-stack-py": "Logique du bot et traitement côté serveur",
    "pa-stack-tg": "Interaction avec les utilisateurs",
    "pa-stack-web": "Interface web et UX",
    "pa-stack-db": "Stockage des utilisateurs et des statistiques",
    "pa-stack-async": "Traitement asynchrone de plusieurs comptes",
    "pa-gallery-title": "Galerie visuelle",
    "pa-gal-cap1": "Tableau de bord administrateur : accès, rôles, contrôle des actions.",
    "pa-gal-cap2": "Parcours utilisateur : interaction sur Telegram et scénarios de participation.",
    "pa-gal-cap3": "Infrastructure : stabilité, stockage des données et évolutivité.",
    "pa-res-title": "Résultat",
    "pa-res-text": "Ce n'est pas simplement un bot, mais un système complet : chaque action est sous contrôle, chaque compte est protégé et l'administrateur dispose d'une vision globale en temps réel. La solution convient à l'automatisation évolutive, au développement modulaire et à une gestion transparente des comptes Telegram.",
    "pa-hide-details": "Masquer les détails",
    "pa-nav-arch": "Architecture",
    "pa-nav-feat": "Fonctionnalités",
    "pa-nav-users": "Utilisateurs",
    "pa-nav-bot": "Bot",
    "pa-nav-db": "Base de données",
    "pa-nav-sec": "Sécurité",
    "pa-nav-stack": "Stack",
    "pa-nav-gal": "Galerie",
    "pa-nav-res": "Résultat",
    "view-all-projects": "Vers la liste des projets",
    "all-projects-title": "Le site web de mon projet",





    "python": {
        "tech-page-title": "Python: Une analyse fondamentale de l'écosystème",
        "tech-main-desc": "Python est un langage de haut niveau qui allie une lisibilité incroyable à de puissantes capacités de bas niveau. Son architecture est construite autour de la machine virtuelle CPython, qui exécute du bytecode compilé, ce qui en fait un outil idéal pour l'automatisation et le développement back-end.",
        "tech-deep-title": "Architecture et mécanismes internes",
        "tech-card-1-title": "L'environnement CPython",
        "tech-card-1-text": "Analyse du fonctionnement de la machine virtuelle, de l'interprétation du bytecode et de l'architecture basée sur une pile.",
        "tech-card-2-title": "Gestion des ressources",
        "tech-card-2-text": "Gestion approfondie de la mémoire via le comptage de références et un ramasse-miettes heuristique.",
        "tech-card-3-title": "Asynchronisme",
        "tech-card-3-text": "Modèle de multitâche coopératif basé sur asyncio pour les systèmes à forte charge.",
        "full-sec-1-title": "1. Cycle de vie du code : de .py au processeur",
        "full-sec-1-text": "Lorsque vous exécutez un script, Python le traduit d'abord en bytecode — un ensemble d'instructions de bas niveau. La machine virtuelle CPython les exécute séquentiellement, assurant ainsi la compatibilité multiplateforme. Cependant, contrairement à Java, Python interprète le bytecode de manière dynamique, offrant la flexibilité de modifier les types de variables à l'exécution. Cela permet d'écrire un code concis et facilement adaptable à toutes les tâches commerciales.",
        "full-sec-2-title": "2. Gestion de la mémoire et le problème du GIL",
        "full-sec-2-text": "En Python, le mécanisme principal de nettoyage de la mémoire est le comptage de références : un objet est supprimé dès qu'il n'y a plus de références pointant vers lui. Pour les références cycliques, on utilise un ramasse-miettes. Une limitation cruciale est le Global Interpreter Lock (GIL). Ce mutex protège la sécurité des données dans les threads mais limite l'exécution parallèle du bytecode dans différents threads. Pour contourner ce problème dans les tâches lourdes, nous utilisons le module multiprocessing ou l'asynchronisme.",
        "full-sec-project-case-title": "3. Application dans le projet : Implémentation et bibliothèques",
        "full-sec-project-case-text": "Comme je l'ai déjà mentionné dans la section principale de mon portfolio, Python est mon outil clé. Dans ce projet, je l'ai utilisé pour construire l'architecture modulaire du bot. Pour garantir la pureté des données, j'ai appliqué la bibliothèque **Pydantic** pour une validation stricte des objets entrants. Toute la logique métier des giveaways a été déplacée dans des services asynchrones séparés, ce qui a permis d'isoler l'API Telegram des calculs lourds. De plus, pour une surveillance approfondie de l'état du système, la bibliothèque **Loguru** a été implémentée, fournissant une journalisation détaillée de chaque étape de l'automatisation."
    },
    "aiogram": {
        "tech-page-title": "Aiogram: Développement professionnel d'interfaces Telegram",
        "tech-main-desc": "Aiogram est un framework entièrement asynchrone construit sur asyncio. Il encourage le développeur à écrire un code propre, typé et modulaire, en utilisant les modèles modernes de développement web.",
        "tech-deep-title": "Composants système",
        "tech-card-1-title": "Advanced Routing",
        "tech-card-1-text": "Système multi-niveaux de filtres et routeurs pour la gestion des flux de données.",
        "tech-card-2-title": "Stateful Logic (FSM)",
        "tech-card-2-text": "Implémentation de parcours utilisateur via la persistance des états dans Redis ou RAM.",
        "tech-card-3-title": "Middlewares",
        "tech-card-3-text": "Couches de traitement intermédiaire pour implémenter une logique transversale (journalisation, anti-spam).",
        "full-sec-1-title": "1. Gestion des événements et Middleware",
        "full-sec-1-text": "Dans Aiogram, chaque événement (Update) traverse une chaîne de Middlewares. Cela permet d'injecter une logique avant que le message n'atteigne le gestionnaire principal. Par exemple, on peut vérifier automatiquement l'abonnement d'un utilisateur à une chaîne ou limiter la fréquence des requêtes (Rate limiting). Cela rend le système protégé contre les abus et permet de déplacer la logique commune dans des couches séparées, sans encombrer le code de traitement des commandes.",
        "full-sec-2-title": "2. Machine à états finis (FSM)",
        "full-sec-2-text": "Pour créer des interfaces complexes, on utilise une Machine à états finis. Elle se souvient à quelle étape du dialogue se trouve l'utilisateur. Pour éviter la perte de données lors d'un redémarrage du bot, nous connectons des stockages externes (Redis/Postgres). C'est la norme pour les solutions d'entreprise, permettant de mettre à jour de manière transparente le code du bot sans interrompre les sessions utilisateur actives.",
        "full-sec-project-case-title": "Application dans le projet : Mécaniques Telegram",
        "full-sec-project-case-text": "Comme je l'ai déjà mentionné sur la page principale de mon portfolio, je me spécialise dans le développement de systèmes Telegram. Dans ce projet, j'ai utilisé **Aiogram 3.x** pour construire une architecture d'interaction asynchrone. J'ai implémenté un système de **Custom Middlewares** pour vérifier automatiquement l'abonnement de l'utilisateur aux chaînes sponsors avant de l'autoriser à participer au giveaway. Une machine à états (**FSM**) avec un stockage dans **Redis** a également été implémentée, permettant aux administrateurs de configurer les giveaways étape par étape (téléchargement de médias, sélection de la date, configuration des conditions) sans perdre la progression même lors d'un redémarrage du serveur. Pour se protéger contre la triche, j'ai intégré des filtres personnalisés côté dispatcher qui éliminent les activités suspectes des bots."
    },
    "postgres": {
        "tech-page-title": "PostgreSQL: Une base de données de niveau industriel",
        "tech-main-desc": "PostgreSQL est un SGBD objet-relationnel connu pour sa fiabilité, sa prise en charge de requêtes complexes et le respect strict des normes ACID.",
        "tech-deep-title": "Détails techniques",
        "tech-card-1-title": "MVCC",
        "tech-card-1-text": "Le contrôle de concurrence multiversion permet de lire les données sans verrous pendant les écritures.",
        "tech-card-2-title": "Conformité ACID",
        "tech-card-2-text": "Garantie de l'intégrité des données même en cas de pannes soudaines d'alimentation ou système.",
        "tech-card-3-title": "Support JSONB",
        "tech-card-3-text": "Gestion efficace de données non structurées dans des tables SQL.",
        "full-sec-1-title": "1. Transactions et intégrité",
        "full-sec-1-text": "Postgres garantit que chaque opération est soit entièrement terminée, soit pas du tout exécutée (atomicité). Le mécanisme de journalisation Write-Ahead Logging (WAL) enregistre toutes les modifications dans un journal avant de les appliquer à la table. Ceci est d'une importance cruciale pour les systèmes financiers ou de jeu, où une erreur dans un seul enregistrement pourrait entraîner une perte de cohérence de l'ensemble de la base de données.",
        "full-sec-2-title": "2. Indexation et recherche",
        "full-sec-2-text": "Nous utilisons non seulement des index B-tree standard, mais aussi des index GIN pour accélérer la recherche dans les champs JSONB. Cela permet à Postgres de combiner la vitesse des solutions NoSQL avec la fiabilité des bases de données relationnelles classiques. Une planification correcte des requêtes (Explain Analyze) permet d'optimiser la charge et de garantir une réponse instantanée même sur des sélections de millions de lignes.",
        "full-sec-project-case-title": "Application dans le projet : Architecture des données",
        "full-sec-project-case-text": "Comme je l'ai déjà mentionné sur la page principale, j'utilise des bases de données pour garantir une stabilité maximale des systèmes. Dans ce projet, j'ai choisi PostgreSQL pour son extensibilité et sa fiabilité. Pour l'intégration avec le code asynchrone du bot, j'ai utilisé **SQLAlchemy** avec le driver **asyncpg**, ce qui a permis à la base de données de fonctionner sans bloquer le thread principal. J'ai conçu le schéma relationnel de sorte que même avec 100 000+ participants, la sélection du gagnant se fasse instantanément. Cela a été réalisé en configurant des index **B-tree** composites sur les champs d'ID utilisateur et d'ID giveaway, garantissant à 100 % la cohérence des données lors des opérations de masse."
    },
    "flask": {
        "tech-page-title": "Flask & FastAPI: Interfaces Web modernes",
        "tech-main-desc": "Micro-frameworks pour créer une logique côté serveur et des API. Flask est utilisé pour des panneaux d'administration flexibles et FastAPI pour des services asynchrones hautes performances avec validation automatique des données.",
        "tech-deep-title": "Fonctionnalités de base",
        "tech-card-1-title": "Conception de microservices",
        "tech-card-1-text": "Architecture sans code superflu — ne connectez que les modules nécessaires pour chaque tâche.",
        "tech-card-2-title": "Validation Pydantic",
        "tech-card-2-text": "Dans FastAPI, les données sont automatiquement validées au niveau des types, éliminant les erreurs de requête.",
        "tech-card-3-title": "Swagger & OpenAPI",
        "tech-card-3-text": "Documentation d'API interactive automatique disponible 'prête à l'emploi'.",
        "full-sec-1-title": "1. API RESTful et Injection de dépendances",
        "full-sec-1-text": "Lors de la conception du back-end, j'adhère aux principes REST. Chaque ressource a sa propre URL et les actions sont définies par les méthodes HTTP standard. FastAPI implémente un puissant système d'injection de dépendances (DI). Cela facilite la gestion des connexions à la base de données, de l'authentification et des paramètres, rendant le code modulaire et adapté aux tests automatiques. Tous les échanges de données se font au format JSON, garantissant une compatibilité idéale avec tous les frameworks frontend.",
        "full-sec-2-title": "2. Templating et E/S asynchrones",
        "full-sec-2-text": "Pour Flask, nous utilisons Jinja2 — un moteur de templates sécurisé. Il permet une génération dynamique de HTML côté serveur en insérant des données Python directement dans le balisage. Dans le cas de FastAPI, on utilise des E/S entièrement asynchrones. Cela signifie que le serveur ne 's'endort' pas lors d'une longue requête à la base de données, mais continue de traiter d'autres appels entrants. Ceci est d'une importance cruciale pour les tableaux de bord de surveillance où les données doivent être mises à jour instantanément."
    },
    "git": {
        "tech-page-title": "Git: Contrôle de version professionnel",
        "tech-main-desc": "Git est un système de contrôle de version distribué qui est la norme de l'industrie. Il permet de sauvegarder un historique des modifications, de travailler en équipe et d'expérimenter en toute sécurité avec le code.",
        "tech-deep-title": "Concepts de base",
        "tech-card-1-title": "Stratégie de branching",
        "tech-card-1-text": "Création de branches isolées pour chaque nouvelle fonctionnalité (développement piloté par les fonctionnalités).",
        "tech-card-2-title": "Modèle snapshot",
        "tech-card-2-text": "Git stocke des instantanés complets de l'état du projet, et non les différences entre fichiers, pour plus de fiabilité.",
        "tech-card-3-title": "Commits atomiques",
        "tech-card-3-text": "Possibilité de diviser les changements en parties logiques pour un retour arrière et une analyse faciles.",
        "full-sec-1-title": "1. Structure interne: instantanés et hachages",
        "full-sec-1-text": "Git est essentiellement une base de données graphe. Chaque commit a un hachage SHA-1 unique, garantissant que le contenu du code n'a pas été modifié inaperçu. Contrairement aux anciens systèmes (SVN), Git stocke des instantanés (snapshots) complets de fichiers. Cela rend instantanées des opérations comme le changement de branche (checkout) et la fusion (merge). La compréhension de concepts tels que 'l'index' (zone de staging) et 'l'arbre' (tree) me permet de gérer efficacement même les conflits de fusion les plus complexes.",
        "full-sec-2-title": "2. Méthodologie Git Flow",
        "full-sec-2-text": "Pour un développement stable, j'utilise Git Flow. La branche principale (main) contient toujours uniquement du code testé et prêt pour la production. Le développement se fait dans la branche 'develop', et chaque nouvelle fonctionnalité est créée dans une branche séparée 'feature/'. Cela évite que du code non terminé ne casse le système fonctionnel. L'utilisation de commandes comme cherry-pick et rebase me permet de maintenir un historique des commits propre et compréhensible, ce qui est essentiel pour la maintenance à long terme du projet."
    },
    "frontend": {
        "tech-page-title": "HTML / CSS / JS: L'interface visuelle",
        "tech-main-desc": "Le trio de technologies qui façonne l'expérience utilisateur. Nous utilisons des normes modernes de balisage, de style et de script pour créer des applications Web rapides et réactives.",
        "tech-deep-title": "Technologies de base",
        "tech-card-1-title": "Mises en page modernes",
        "tech-card-1-text": "Mise en page avec Flexbox et Grid pour un affichage parfait sur tous les types d'appareils.",
        "tech-card-2-title": "Normes ES6+",
        "tech-card-2-text": "Utilisation de l'asynchronisme et des modules en JS pour un fonctionnement fluide de l'interface.",
        "tech-card-3-title": "Conception UX / UI",
        "tech-card-3-text": "Accent mis sur l'intuitivité, l'accessibilité et les effets visuels modernes (Glassmorphisme).",
        "full-sec-1-title": "1. DOM et JavaScript asynchrone",
        "full-sec-1-text": "Le frontend moderne ne se résume pas à des pages statiques. Avec JavaScript, je manipule l'arbre DOM (Document Object Model), modifiant dynamiquement l'interface en réponse aux actions de l'utilisateur. L'utilisation de l'API Fetch permet l'échange de données avec le back-end en arrière-plan. Cela crée l'effet d'une application monopage (SPA), où la page ne se recharge pas complètement mais met seulement à jour en douceur les blocs de données nécessaires, améliorant considérablement le confort de l'utilisateur.",
        "full-sec-2-title": "2. Architecture CSS et animations",
        "full-sec-2-text": "Pour le style, j'utilise des variables CSS et des méthodes de positionnement modernes. Cela facilite l'implémentation de thèmes sombres et clairs. Les animations sont implémentées avec l'accélération matérielle (transform: translate3d), garantissant une fluidité de 60 FPS même sur les appareils mobiles. Une attention particulière est portée à la méthodologie de mise en page: je sépare les styles en modules logiques afin qu'ils puissent être facilement réutilisés dans différentes parties du projet.",
        "full-sec-project-case-title": "Application dans le projet : Interface interactive",
        "full-sec-project-case-text": "Comme je l'ai déjà mentionné sur la page principale de mon portfolio, je porte une grande attention non seulement au code mais aussi au confort visuel de l'utilisateur. Dans ce projet, j'ai implémenté un panneau d'administration réactif en **JavaScript** pur sans utiliser de frameworks lourds, ce qui a garanti un chargement instantané. J'ai appliqué des techniques de mise en page modernes (Flexbox et CSS Grid) pour créer une interface 'verre' complexe (Glassmorphisme) qui reste lisible sur n'importe quel appareil. Toute la communication avec le back-end se fait via des requêtes asynchrones **Fetch API**, permettant à l'administrateur de gérer les giveaways et de suivre les statistiques des participants sans avoir à recharger la page."
    },
    "asyncio": {
        "tech-page-title": "Asyncio: L'asynchronisme profond en Python",
        "tech-main-desc": "Asyncio est une bibliothèque pour écrire du code concurrent en utilisant la syntaxe async/await. C'est le fondement des systèmes modernes à forte charge gérant des milliers de connexions réseau simultanément.",
        "tech-deep-title": "Concepts asynchrones",
        "tech-card-1-title": "Event Loop",
        "tech-card-1-text": "La boucle centrale qui gère l'exécution de toutes les tâches dans un seul thread.",
        "tech-card-2-title": "Coroutines",
        "tech-card-2-text": "Des fonctions qui peuvent suspendre leur travail sans bloquer l'ensemble du programme.",
        "tech-card-3-title": "E/S non bloquantes",
        "tech-card-3-text": "Le système n'attend pas les réponses réseau, passant instantanément à d'autres tâches.",
        "full-sec-1-title": "1. Multitâche coopératif",
        "full-sec-1-text": "Contrairement aux threads classiques, Asyncio utilise un modèle où les coroutines rendent le contrôle à la boucle d'événements. Cela élimine les conditions de concurrence pour les données partagées et permet à un seul processus de servir un nombre colossal de requêtes, en consommant dix fois moins de RAM. Cela rend Python idéal pour les microservices et les bots.",
        "full-sec-2-title": "2. Scalabilité des appels réseau",
        "full-sec-2-text": "Asyncio fonctionne sur des appels système de bas niveau (epoll/kqueue), lui permettant de surveiller des milliers de sockets. Le programme « dort » au niveau du noyau de l'OS jusqu'à l'arrivée des données. Cela garantit que la latence d'une requête n'affecte pas le débit global de l'ensemble du système.",
        "full-sec-project-case-title": "Application dans le projet : Multi-comptes et rapidité",
        "full-sec-project-case-text": "**Je n'ai pas mentionné Asyncio sur la page principale**, mais dans ce projet, c'était une technologie clé. J'ai utilisé l'asynchronisme pour implémenter le **multi-comptes** — le bot peut travailler avec différentes sessions Telegram simultanément sans interférence. En utilisant `asyncio.gather()`, j'ai configuré des vérifications parallèles d'abonnement dans 5 à 10 canaux à la fois. Cela a réduit le temps d'attente de l'utilisateur de plusieurs secondes à quelques millisecondes. Les files d'attente asynchrones (Tasks) ont également assuré des envois en arrière-plan stables qui ne ralentissent pas l'interface principale du bot pendant les giveaways actifs."
    }
}