{
    "nav-about": "Über mich", 
    "nav-projects": "Projekte", 
    "nav-contacts": "Kontakte",
    "hero-eyebrow": "Pasha", 
    "hero-name": "Telegram-Systementwickler", 
    "hero-btn": "Projekte ansehen",
    "hero-tagline": "Ich baue stabile, skalierbare Automatisierungssysteme, die echte Geschäftsprobleme lösen. Von der Architektur bis zur Bereitstellung.",
    "about-title": "Über mich", 
    "about-text": "Ich bin eine Person, der es wichtig ist zu verstehen, wie und warum alles funktioniert. Ich interessiere mich für Systeme: technische, logische und menschliche. Ich mag kein Chaos und keine Zufallsentscheidungen, daher zerlege ich jede Idee in ihre Struktur und bringe sie in einen funktionierenden, stabilen Zustand.",
    "about-h-approach": "Ansatz", 
    "about-app-1": "Erst Architektur, dann Implementierung", 
    "about-app-2": "Analyse von Fehlerstellen und Skalierbarkeit", 
    "about-app-3": "Ein System, keine Sammlung unzusammenhängender Funktionen",
    "about-h-prog": "Programmierung", 
    "about-prog-1": "Python, asynchrone Logik, Web-Schnittstellen", 
    "about-prog-2": "Automatisierung, Ereignisse, Datenbanken", 
    "about-prog-3": "Lesbare Struktur und erweiterbarer Code",
    "about-h-tg": "Telegram", 
    "about-tg-1": "Bots als Teil eines Gesamtsystems", 
    "about-tg-2": "Bundle: Bot + Web-Schnittstelle + Datenbank", 
    "about-tg-3": "Echtzeit-Überwachung und -Steuerung",
    "about-h-val": "Werte", 
    "about-val-1": "Ehrlichkeit und Direktheit", 
    "about-val-2": "Ruhiger, professioneller Dialog", 
    "about-val-3": "Durchdachter Stil in Code und Benutzeroberfläche",
    "tech-title": "Tech Stack",
    "flow-title": "Wie ich arbeite",
    "flow-1-title": "Analyse",
    "flow-1-desc": "Tiefes Verständnis des Ziels.",
    "flow-2-title": "Architektur",
    "flow-2-desc": "Entwurf der Logik.",
    "flow-3-title": "Implementierung",
    "flow-3-desc": "Sauberen Code schreiben.",
    "flow-4-title": "Testen",
    "flow-4-desc": "Stabilität gewährleisten.",
    "flow-5-title": "Support",
    "flow-5-desc": "Langfristige Zuverlässigkeit.",
    "proj-title": "Projekte", 
    "proj-badge": "1 aktiv", 
    "proj-name": "Gewinnspiel-Bot & Admin-Dashboard", 
    "proj-status": "Aktive Entwicklung", 
    "proj-more": "Mehr Details", 
    "proj-tech-stack": "Stack: Python, Aiogram, SQLite",
    "proj-desc-1": "Automatisches Gewinnspiel-Managementsystem mit Admin-Panel und Analytik.",
    "cont-title": "Kontakte",
    "cont-note-text": "Wenn die Kontakt-Buttons auf Ihrem Gerät nicht funktionieren, finden Sie hier meine direkten Kontaktdaten:",
    "cont-note-gh-label": "GitHub:",
    "cont-note-mail-label": "Gmail:",
    "pa-back": "← Zurück zu den Projekten",
    "pa-eyebrow": "Fallstudie",
    "pa-tagline": "Integriertes System zur Verwaltung von Telegram-Konten: Web-Admin-Panel, automatisierter Bot, Zugriffskontrolle und Analytik in einem Produkt.",
    "pa-status": "In aktiver Entwicklung",
    "pa-read-more": "Mehr lesen",
    "pa-read-less": "Weniger anzeigen",
    "pa-problem-title": "Problem",
    "pa-problem-text": "Das manuelle Verwalten mehrerer Telegram-Konten für Gewinnspiele ist ineffizient und fehleranfällig. Nutzer benötigen Anonymität, während Administratoren zentrale Kontrolle und Transparenz ohne direkten Zugriff auf sensible Daten benötigen.",
    "pa-solution-title": "Lösung",
    "pa-solution-text": "Ich habe ein umfassendes System entwickelt, bestehend aus einem Telegram-Bot für automatische Aktionen, einem webbasierten Admin-Dashboard für die Verwaltung und einer sicheren Datenbank. Das System gewährleistet die sichere Teilnahme an Gewinnspielen und bietet Echtzeit-Analysen.",
    "pa-arch-text": "Bot → Backend → Datenbank → Admin Panel",
    "pa-features-title": "Funktionen",
    "pa-feat-1": "Rollensystem: Granulare Zugriffskontrolle für Admins und Nutzer.",
    "pa-feat-2": "Zugriffskontrolle: Sicherer Login und Aktionsautorisierung.",
    "pa-feat-3": "Logging: Detaillierte Protokolle aller Bot- und Admin-Aktionen.",
    "pa-feat-4": "Automatisierungslogik: Intelligente Skripte für Gewinnspielteilnahmen.",
    "pa-feat-5": "Monitoring: Echtzeit-Status aller verbundenen Konten.",
    "pa-concept-title": "Allgemeines Konzept",
    "pa-concept-text": "Das Hauptziel des Systems ist es, die Teilnahme von Konten an Gewinnspielen zu automatisieren, die Anonymität der Nutzer zu gewährleisten und dem Administrator die vollständige Kontrolle über eine Weboberfläche zu bieten. Die Architektur ist modular und skalierbar: Neue Funktionen können hinzugefügt werden, ohne den gesamten Code neu zu schreiben.",
    "pa-users-title": "Benutzer und Zugriff",
    "pa-admin-h": "Für den Administrator",
    "pa-admin-li1": "Erstellung von Benutzern mit ID, Name und Benutzername.",
    "pa-admin-li2": "Zuweisung von Rollen, Einschränkungen und Zugriffsrechten.",
    "pa-admin-li3": "Verknüpfung eines oder mehrerer Konten mit einem Benutzer.",
    "pa-admin-li4": "Vollständige Kontrolle über die Bot-Funktionen.",
    "pa-user-h": "Für den Benutzer",
    "pa-user-li1": "Der Zugriff auf den Bot erfolgt erst nach Aktivierung über die Website.",
    "pa-user-li2": "Verwaltung mehrerer Konten unter einer ID.",
    "pa-user-li3": "Anzeige von Statistiken: Teilnahme, Erfolgsquote, Aktivität.",
    "pa-user-li4": "Sicherer Ablauf mit Codes und Passwörtern.",
    "pa-bot-title": "Telegram-Bot",
    "pa-bot-li1": "Nimmt automatisch an Gewinnspielen teil: Abonnements, Captchas, skriptbasierte Aktionen.",
    "pa-bot-li2": "Überwacht die Kontoaktivität und zeigt dem Benutzer Statistiken an.",
    "pa-bot-li3": "Mit der Website über die Datenbank synchronisiert: Änderungen im Panel wirken sich sofort auf den Bot aus.",
    "pa-bot-li4": "Asynchrone Verarbeitung ermöglicht die gleichzeitige Verwaltung mehrerer Konten.",
    "pa-bot-li5": "Nur aktive und autorisierte Konten nehmen an Kampagnen teil.",
    "pa-db-title": "Datenbank und Admin-Panel",
    "pa-db-struct-h": "Datenbankstruktur",
    "pa-db-struct-p": "Benutzer, Konten, Statistiken und Protokolle. Der Zustand bleibt nach einem Neustart erhalten; Analysen und Export sind verfügbar.",
    "pa-db-manage-h": "Verwaltung",
    "pa-db-manage-p": "Hinzufügen, Bearbeiten und Löschen von Benutzern/Konten, Steuerung der Bot-Aktionen und Zugriffsrechte.",
    "pa-db-ui-h": "Benutzeroberfläche",
    "pa-db-ui-p": "Tabellen, Karten, Filterung, Aktivitätsvisualisierung, Hover-Effekte und responsives Navigationsdesign.",
    "pa-sec-title": "Sicherheit und Anonymität",
    "pa-sec-li1": "Persönliche Daten sind verborgen und nur für den Administrator zugänglich.",
    "pa-sec-li2": "Der Zugriff auf Konten ist durch Codes und Passwörter geschützt.",
    "pa-sec-li3": "Bot- und Administratoraktionen werden protokolliert, ohne private Informationen offenzulegen.",
    "pa-sec-li4": "Die modulare Architektur reduziert das Risiko von Fehlern und Sicherheitslücken.",
    "pa-adv-title": "Zentrale Vorteile",
    "pa-adv-li1": "Zentralisierte Verwaltung von Benutzern und Konten.",
    "pa-adv-li2": "Automatisierung der Teilnahme an Gewinnspielen ohne manuelle Routineaufgaben.",
    "pa-adv-li3": "Detaillierte Analysen für Konten und Benutzer.",
    "pa-adv-li4": "Sicherheit, Anonymität und transparente Verwaltung.",
    "pa-adv-li5": "Einfache Erweiterung und Integration neuer Module.",
    "pa-stack-title": "Technologie-Stack",
    "pa-stack-py": "Bot-Logik und serverseitige Verarbeitung",
    "pa-stack-tg": "Interaktion mit Benutzern",
    "pa-stack-web": "Weboberfläche und UX",
    "pa-stack-db": "Speicherung von Benutzern und Statistiken",
    "pa-stack-async": "Asynchrone Verarbeitung mehrerer Konten",
    "pa-gallery-title": "Visuelle Galerie",
    "pa-gal-cap1": "Admin-Dashboard: Zugriff, Rollen, Aktionskontrolle.",
    "pa-gal-cap2": "Benutzerpfad: Telegram-Interaktion und Teilnahme-Szenarien.",
    "pa-gal-cap3": "Infrastruktur: Stabilität, Datenspeicherung und Skalierbarkeit.",
    "pa-res-title": "Ergebnis",
    "pa-res-text": "Dies ist nicht nur ein Bot, sondern ein vollständiges System: Jede Aktion steht unter Kontrolle, jedes Konto ist geschützt und der Administrator sieht das Gesamtbild in Echtzeit. Die Lösung eignet sich für skalierbare Automatisierung, modulare Entwicklung und transparente Verwaltung von Telegram-Konten.",
    "pa-hide-details": "Details ausblenden",
    "pa-nav-arch": "Architektur",
    "pa-nav-feat": "Funktionen",
    "pa-nav-users": "Benutzer",
    "pa-nav-bot": "Bot",
    "pa-nav-db": "Datenbank",
    "pa-nav-sec": "Sicherheit",
    "pa-nav-stack": "Stack",
    "pa-nav-gal": "Galerie",
    "pa-nav-res": "Ergebnis",
    "view-all-projects": "Zur Projektliste",



    "python": {
        "tech-page-title": "Python: Eine grundlegende Analyse des Ökosystems",
        "tech-main-desc": "Python ist eine hochrangige Sprache, die unglaubliche Lesbarkeit mit leistungsstarken Low-Level-Funktionen kombiniert. Seine Architektur basiert auf der CPython-Virtual Machine, die kompilierten Bytecode ausführt, was ihn zu einem idealen Werkzeug für Automatisierung und Backend-Entwicklung macht.",
        "tech-deep-title": "Architektur und interne Mechanismen",
        "tech-card-1-title": "Die CPython-Umgebung",
        "tech-card-1-text": "Analyse der Funktionsweise der virtuellen Maschine, der Bytecode-Interpretation und der stack-basierten Architektur.",
        "tech-card-2-title": "Ressourcenverwaltung",
        "tech-card-2-text": "Tiefgreifende Speicherverwaltung durch Referenzzählung und einen heuristischen Garbage Collector.",
        "tech-card-3-title": "Asynchronität",
        "tech-card-3-text": "Ein kooperatives Multitasking-Modell basierend auf asyncio für hochbelastete Systeme.",
        "full-sec-1-title": "1. Lebenszyklus des Codes: Von .py bis zum Prozessor",
        "full-sec-1-text": "Wenn Sie ein Skript ausführen, übersetzt Python es zunächst in Bytecode – einen Satz von Low-Level-Anweisungen. Die CPython-Virtual Machine führt sie sequentiell aus, was Plattformunabhängigkeit gewährleistet. Im Gegensatz zu Java interpretiert Python Bytecode jedoch dynamisch, was die Flexibilität bietet, Variablentypen zur Laufzeit zu ändern. Dies ermöglicht das Schreiben von prägnantem Code, der sich leicht an jede geschäftliche Aufgabe anpassen lässt.",
        "full-sec-2-title": "2. Speicherverwaltung und das GIL-Problem",
        "full-sec-2-text": "In Python ist der primäre Mechanismus zur Speicherbereinigung die Referenzzählung: Ein Objekt wird gelöscht, sobald keine Referenzen mehr darauf verweisen. Für zyklische Referenzen wird ein Garbage Collector verwendet. Eine entscheidende Einschränkung ist die Global Interpreter Lock (GIL). Diese Mutex schützt die Thread-Sicherheit von Daten, schränkt aber die parallele Ausführung von Bytecode in verschiedenen Threads ein. Um dies bei aufwändigen Aufgaben zu umgehen, verwenden wir das Modul multiprocessing oder Asynchronität.",
        "full-sec-project-case-title": "3. Projekteinsatz: Implementierung und Bibliotheken",
        "full-sec-project-case-text": "Wie ich bereits im Hauptteil meines Portfolios erwähnte, ist Python mein Schlüsselwerkzeug. In diesem Projekt habe ich es verwendet, um die modulare Architektur des Bots zu erstellen. Um die Datenreinheit zu gewährleisten, habe ich die Bibliothek **Pydantic** zur strengen Validierung eingehender Objekte eingesetzt. Die gesamte Geschäftslogik der Gewinnspiele wurde in separate asynchrone Dienste ausgelagert, was es ermöglichte, die Telegram-API von rechenintensiven Aufgaben zu isolieren. Zur eingehenden Überwachung des Systemzustands wurde außerdem die Bibliothek **Loguru** implementiert, die eine detaillierte Protokollierung jedes Automatisierungsschritts gewährleistet."
    },
    "aiogram": {
        "tech-page-title": "Aiogram: Professionelle Entwicklung von Telegram-Schnittstellen",
        "tech-main-desc": "Aiogram ist ein vollständig asynchrones Framework, das auf asyncio basiert. Es ermutigt Entwickler, sauberen, typisierten und modularen Code unter Verwendung moderner Webentwicklungsmuster zu schreiben.",
        "tech-deep-title": "Systemkomponenten",
        "tech-card-1-title": "Advanced Routing",
        "tech-card-1-text": "Ein mehrstufiges System von Filtern und Routern zur Steuerung von Datenflüssen.",
        "tech-card-2-title": "Stateful Logic (FSM)",
        "tech-card-2-text": "Implementierung von Benutzerpfaden durch Speicherung von Zuständen in Redis oder RAM.",
        "tech-card-3-title": "Middlewares",
        "tech-card-3-text": "Zwischenverarbeitungsschichten zur Implementierung übergreifender Logik (Protokollierung, Anti-Spam).",
        "full-sec-1-title": "1. Ereignisbehandlung und Middleware",
        "full-sec-1-text": "In Aiogram durchläuft jedes Ereignis (Update) eine Kette von Middlewares. Dies ermöglicht es, Logik zu injizieren, bevor die Nachricht den Haupt-Handler erreicht. Beispielsweise können Sie automatisch überprüfen, ob ein Benutzer einen Kanal abonniert hat, oder die Anforderungshäufigkeit begrenzen (Rate Limiting). Dies macht das System vor Missbrauch geschützt und ermöglicht es, gemeinsame Logik in separate Schichten auszulagern, ohne den Code für die Befehlsverarbeitung zu überladen.",
        "full-sec-2-title": "2. Endlicher Automat (FSM)",
        "full-sec-2-text": "Zur Erstellung komplexer Schnittstellen wird ein endlicher Automat (Finite State Machine) verwendet. Er merkt sich, in welcher Phase des Dialogs sich der Benutzer befindet. Um Datenverlust beim Neustart des Bots zu vermeiden, binden wir externe Speicher (Redis/Postgres) ein. Dies ist der Standard für Enterprise-Lösungen und ermöglicht es, den Bot-Code nahtlos zu aktualisieren, ohne aktive Benutzersitzungen zu unterbrechen.",
        "full-sec-project-case-title": "Projekteinsatz: Telegram-Mechaniken",
        "full-sec-project-case-text": "Wie ich bereits auf der Hauptseite meines Portfolios erwähnte, spezialisiere ich mich auf die Entwicklung von Telegram-Systemen. In diesem Projekt habe ich **Aiogram 3.x** verwendet, um eine asynchrone Interaktionsarchitektur zu erstellen. Ich habe ein System von **Custom Middlewares** implementiert, um automatisch die Kanalabonnements von Benutzern bei Sponsor-Kanälen zu überprüfen, bevor sie Zugang zum Gewinnspiel erhalten. Ebenfalls implementiert wurde ein endlicher Automat (**FSM**) mit **Redis**-Speicher, der es Administratoren ermöglicht, Gewinnspiele Schritt für Schritt zu konfigurieren (Medien hochladen, Datum auswählen, Bedingungen festlegen), ohne den Fortschritt selbst bei einem Server-Neustart zu verlieren. Zum Schutz vor Betrug habe ich benutzerdefinierte Filter auf Dispatcher-Seite integriert, die verdächtige Bot-Aktivitäten ausschließen."
    },
    "postgres": {
        "tech-page-title": "PostgreSQL: Eine Datenbank auf Industrieniveau",
        "tech-main-desc": "PostgreSQL ist ein objektrelationales DBMS, das für seine Zuverlässigkeit, Unterstützung komplexer Abfragen und strenge Einhaltung der ACID-Standards bekannt ist.",
        "tech-deep-title": "Technische Details",
        "tech-card-1-title": "MVCC",
        "tech-card-1-text": "Multi-Version Concurrency Control ermöglicht das Lesen von Daten ohne Sperren während des Schreibens.",
        "tech-card-2-title": "ACID-Konformität",
        "tech-card-2-text": "Garantie der Datenintegrität auch bei plötzlichen Stromausfällen oder Systemabstürzen.",
        "tech-card-3-title": "JSONB-Unterstützung",
        "tech-card-3-text": "Effiziente Handhabung unstrukturierter Daten in SQL-Tabellen.",
        "full-sec-1-title": "1. Transaktionen und Integrität",
        "full-sec-1-text": "Postgres garantiert, dass jede Operation entweder vollständig ausgeführt oder gar nicht ausgeführt wird (Atomarität). Der Write-Ahead Logging (WAL)-Mechanismus zeichnet alle Änderungen in einem Protokoll auf, bevor sie in die Tabelle übernommen werden. Dies ist für Finanz- oder Spielsysteme von entscheidender Bedeutung, da ein Fehler in einem einzelnen Datensatz zu einem Konsistenzverlust der gesamten Datenbank führen kann.",
        "full-sec-2-title": "2. Indizierung und Suche",
        "full-sec-2-text": "Wir verwenden nicht nur standardmäßige B-Baum-Indizes, sondern auch GIN-Indizes, um die Suche in JSONB-Feldern zu beschleunigen. Dies ermöglicht es Postgres, die Geschwindigkeit von NoSQL-Lösungen mit der Zuverlässigkeit klassischer relationaler Datenbanken zu kombinieren. Eine korrekte Abfrageplanung (Explain Analyze) optimiert die Auslastung und gewährleistet eine sofortige Antwort selbst bei Millionenselektionen.",
        "full-sec-project-case-title": "Projekteinsatz: Datenarchitektur",
        "full-sec-project-case-text": "Wie ich bereits auf der Hauptseite erwähnte, verwende ich Datenbanken, um maximale Systemstabilität zu gewährleisten. In diesem Projekt habe ich mich aufgrund seiner Erweiterbarkeit und Zuverlässigkeit für PostgreSQL entschieden. Für die Integration mit dem asynchronen Bot-Code habe ich **SQLAlchemy** zusammen mit dem **asyncpg**-Treiber verwendet, was der Datenbank ermöglichte, ohne Blockierung des Hauptthreads zu arbeiten. Ich habe das relationale Schema so entworfen, dass selbst bei über 100.000 Teilnehmern die Gewinnerauswahl sofort erfolgt. Dies wurde durch die Einrichtung zusammengesetzter **B-Baum-Indizes** auf Benutzer-ID- und Gewinnspiel-ID-Felder erreicht, was eine 100%ige Datenkonsistenz bei Massenvorgängen garantiert."
    },
    "flask": {
        "tech-page-title": "Flask & FastAPI: Moderne Webschnittstellen",
        "tech-main-desc": "Micro-Frameworks zur Erstellung serverseitiger Logik und APIs. Flask wird für flexible Administrationspanels verwendet und FastAPI für leistungsstarke asynchrone Dienste mit automatischer Datenvalidierung.",
        "tech-deep-title": "Kernfunktionen",
        "tech-card-1-title": "Microservices-Design",
        "tech-card-1-text": "Architektur ohne überflüssigen Code – binden Sie nur die Module ein, die Sie für jede Aufgabe benötigen.",
        "tech-card-2-title": "Pydantic-Validierung",
        "tech-card-2-text": "In FastAPI werden Daten automatisch auf Typebene validiert, wodurch Anforderungsfehler vermieden werden.",
        "tech-card-3-title": "Swagger & OpenAPI",
        "tech-card-3-text": "Automatische interaktive API-Dokumentation ist sofort 'out of the box' verfügbar.",
        "full-sec-1-title": "1. RESTful-API und Dependency Injection",
        "full-sec-1-text": "Beim Entwurf des Backends halte ich mich an die REST-Prinzipien. Jede Ressource hat ihre eigene URL, und Aktionen werden durch standardmäßige HTTP-Methoden definiert. FastAPI implementiert ein leistungsstarkes System zur Abhängigkeitsinjektion (DI). Dies erleichtert die Verwaltung von Datenbankverbindungen, Authentifizierung und Einstellungen, macht den Code modular und für automatische Tests geeignet. Der gesamte Datenaustausch erfolgt im JSON-Format, was eine ideale Kompatibilität mit allen Frontend-Frameworks gewährleistet.",
        "full-sec-2-title": "2. Templating und asynchrone E/A",
        "full-sec-2-text": "Für Flask verwenden wir Jinja2 – eine sichere Template-Engine. Sie ermöglicht die dynamische Generierung von HTML auf dem Server, indem Daten aus Python direkt in das Markup eingefügt werden. Im Fall von FastAPI wird vollständig asynchrone E/A verwendet. Das bedeutet, dass der Server während einer langen Datenbankabfrage nicht 'einschläft', sondern weiterhin andere eingehende Aufrufe bearbeitet. Dies ist für Monitoring-Dashboards von entscheidender Bedeutung, bei denen Daten sofort aktualisiert werden müssen."
    },
    "git": {
        "tech-page-title": "Git: Professionelle Versionskontrolle",
        "tech-main-desc": "Git ist ein verteiltes Versionskontrollsystem, das den Industriestandard darstellt. Es ermöglicht das Speichern eines Verlaufs von Änderungen, die Zusammenarbeit im Team und das sichere Experimentieren mit Code.",
        "tech-deep-title": "Kernkonzepte",
        "tech-card-1-title": "Branching-Strategie",
        "tech-card-1-text": "Erstellung isolierter Branches für jede neue Funktion (Feature-driven Development).",
        "tech-card-2-title": "Snapshot-Modell",
        "tech-card-2-text": "Git speichert vollständige Snapshots des Projektzustands, nicht Dateiunterschiede, für Zuverlässigkeit.",
        "tech-card-3-title": "Atomare Commits",
        "tech-card-3-text": "Die Möglichkeit, Änderungen in logische Teile aufzuteilen, um einfaches Zurücksetzen und Analysieren zu ermöglichen.",
        "full-sec-1-title": "1. Interne Struktur: Snapshots und Hashes",
        "full-sec-1-text": "Git ist im Wesentlichen eine Graphdatenbank. Jeder Commit hat einen eindeutigen SHA-1-Hash, der garantiert, dass der Code-Inhalt nicht unbemerkt verändert wurde. Im Gegensatz zu älteren Systemen (SVN) speichert Git vollständige Datei-Snapshots. Dies macht Operationen wie das Wechseln zwischen Branches (Checkout) und das Zusammenführen (Merge) augenblicklich. Das Verständnis von Konzepten wie 'Index' (Staging-Area) und 'Baum' (Tree) ermöglicht es mir, selbst die komplexesten Merge-Konflikte effizient zu verwalten.",
        "full-sec-2-title": "2. Git-Flow-Methodik",
        "full-sec-2-text": "Für eine stabile Entwicklung verwende ich Git Flow. Der Hauptbranch (main) enthält immer nur getesteten, produktionsreifen Code. Die Entwicklung erfolgt im Branch 'develop', und jede neue Funktion wird in einem separaten Branch 'feature/' erstellt. Dies verhindert, dass unfertiger Code das funktionierende System beeinträchtigt. Die Verwendung von Befehlen wie cherry-pick und rebase ermöglicht es mir, eine saubere und verständliche Commit-Historie zu erhalten, was für die langfristige Projektwartung entscheidend ist."
    },
    "frontend": {
        "tech-page-title": "HTML / CSS / JS: Die visuelle Schnittstelle",
        "tech-main-desc": "Das Trio der Technologien, die das Benutzererlebnis prägen. Wir verwenden moderne Standards für Auszeichnung, Styling und Skripting, um schnelle und reaktionsfähige Webanwendungen zu erstellen.",
        "tech-deep-title": "Kerntechnologien",
        "tech-card-1-title": "Moderne Layouts",
        "tech-card-1-text": "Layout mit Flexbox und Grid für eine perfekte Darstellung auf allen Gerätetypen.",
        "tech-card-2-title": "ES6+-Standards",
        "tech-card-2-text": "Verwendung von Asynchronität und Modulen in JS für einen reibungslosen Betrieb der Benutzeroberfläche.",
        "tech-card-3-title": "UX / UI-Design",
        "tech-card-3-text": "Fokus auf Intuitivität, Barrierefreiheit und moderne visuelle Effekte (Glassmorphismus).",
        "full-sec-1-title": "1. DOM und asynchrones JavaScript",
        "full-sec-1-text": "Modernes Frontend ist nicht nur statische Seiten. Mit JavaScript manipuliere ich den DOM-Baum (Document Object Model) und ändere die Oberfläche dynamisch als Reaktion auf Benutzeraktionen. Die Verwendung der Fetch-API ermöglicht den Datenaustausch mit dem Backend im Hintergrund. Dies erzeugt den Effekt einer Single Page Application (SPA), bei der die Seite nicht vollständig neu geladen wird, sondern nur die erforderlichen Datenblöcke glatt aktualisiert werden, was den Benutzerkomfort erheblich erhöht.",
        "full-sec-2-title": "2. CSS-Architektur und Animationen",
        "full-sec-2-text": "Für das Styling verwende ich CSS-Variablen und moderne Positionierungsmethoden. Dies erleichtert die Implementierung dunkler und heller Themes. Animationen werden mit Hardwarebeschleunigung (transform: translate3d) implementiert, was auch auf mobilen Geräten eine flüssige Darstellung mit 60 FPS garantiert. Besonderes Augenmerk wird auf die Layout-Methodik gelegt: Ich unterteile Stile in logische Module, damit sie in verschiedenen Teilen des Projekts leicht wiederverwendet werden können.",
        "full-sec-project-case-title": "Projekteinsatz: Interaktive Oberfläche",
        "full-sec-project-case-text": "Wie ich bereits auf der Hauptseite meines Portfolios erwähnte, lege ich großen Wert nicht nur auf den Code, sondern auch auf den visuellen Komfort des Benutzers. In diesem Projekt habe ich ein responsives Admin-Panel in reinem **JavaScript** ohne Verwendung schwerer Frameworks implementiert, was ein sofortiges Laden gewährleistete. Ich habe moderne Layout-Techniken (Flexbox und CSS Grid) angewendet, um eine komplexe 'Glas'-Oberfläche (Glassmorphismus) zu schaffen, die auf jedem Gerät lesbar bleibt. Die gesamte Kommunikation mit dem Backend erfolgt über asynchrone **Fetch-API**-Anfragen, was es dem Administrator ermöglicht, Gewinnspiele zu verwalten und Teilnehmerstatistiken zu verfolgen, ohne die Seite neu laden zu müssen."
    },
    "asyncio": {
        "tech-page-title": "Asyncio: Tiefgreifende Asynchronität in Python",
        "tech-main-desc": "Asyncio ist eine Bibliothek zum Schreiben von nebenläufigem Code unter Verwendung der Async/Await-Syntax. Sie ist die Grundlage für moderne hochbelastete Systeme, die Tausende von Netzwerkverbindungen gleichzeitig verarbeiten.",
        "tech-deep-title": "Asynchrone Konzepte",
        "tech-card-1-title": "Event Loop",
        "tech-card-1-text": "Die zentrale Schleife, die die Ausführung aller Aufgaben in einem einzelnen Thread verwaltet.",
        "tech-card-2-title": "Coroutines",
        "tech-card-2-text": "Funktionen, die ihre Arbeit unterbrechen können, ohne das gesamte Programm zu blockieren.",
        "tech-card-3-title": "Nicht blockierende E/A",
        "tech-card-3-text": "Das System wartet nicht auf Netzwerkantworten, sondern wechselt sofort zu anderen Aufgaben.",
        "full-sec-1-title": "1. Kooperatives Multitasking",
        "full-sec-1-text": "Im Gegensatz zu klassischen Threads verwendet Asyncio ein Modell, bei dem Koroutinen die Kontrolle an die Ereignisschleife zurückgeben. Dies beseitigt Wettlaufsituationen bei gemeinsam genutzten Daten und ermöglicht es einem einzelnen Prozess, eine enorme Anzahl von Anfragen zu bedienen, wobei er zehnmal weniger RAM verbraucht. Das macht Python ideal für Mikrodienste und Bots.",
        "full-sec-2-title": "2. Skalierbarkeit von Netzwerkaufrufen",
        "full-sec-2-text": "Asyncio arbeitet auf der Ebene niedriger Systemaufrufe (epoll/kqueue) und kann so Tausende von Sockets überwachen. Das Programm 'schläft' auf der Ebene des Betriebssystemkerns, bis Daten eintreffen. Dadurch wird sichergestellt, dass die Latenz einer Anfrage nicht den Gesamtdurchsatz des gesamten Systems beeinträchtigt.",
        "full-sec-project-case-title": "Projekteinsatz: Multi-Accounting und Geschwindigkeit",
        "full-sec-project-case-text": "**Ich habe Asyncio auf der Hauptseite nicht erwähnt**, aber in diesem Projekt war es eine Schlüsseltechnologie. Ich habe Asynchronität genutzt, um **Multi-Accounting** zu implementieren – der Bot kann gleichzeitig mit verschiedenen Telegram-Sitzungen arbeiten, ohne sich gegenseitig zu stören. Mit `asyncio.gather()` habe ich parallele Abonnementprüfungen in 5-10 Kanälen gleichzeitig eingerichtet. Dadurch verkürzte sich die Wartezeit für den Benutzer von mehreren Sekunden auf Millisekunden. Asynchrone Warteschlangen (Tasks) sorgten zudem für stabile Hintergrundmailings, die die Hauptschnittstelle des Bots während aktiver Gewinnspiele nicht verlangsamen."
    }
}

