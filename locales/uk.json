{
    "nav-about": "Про мене",
    "nav-projects": "Проєкти",
    "nav-contacts": "Контакти",
    "hero-eyebrow": "Павло",
    "hero-name": "Розробник Telegram-систем", 
    "hero-btn": "Дивитися проєкти",
    "hero-tagline": "Я будую стабільні, масштабовані системи автоматизації, які вирішують реальні бізнес-задачі. Від архітектури до впровадження.",
    "about-title": "Про мене",
    "about-text": "Я людина, якій важливо розуміти, як і чому все працює. Мене цікавлять системи: технічні, логічні та людські. Я не люблю хаос і випадкові рішення, тому розкладаю будь-яку ідею на структуру і доводжу її до робочого, стабільного стану.",
    "about-h-approach": "Підхід",
    "about-app-1": "Спочатку архітектура, потім реалізація",
    "about-app-2": "Аналіз точок відмови та масштабованості",
    "about-app-3": "Система, а не набір непов'язаних функцій",
    "about-h-prog": "Програмування",
    "about-prog-1": "Python, асинхронна логіка, веб-інтерфейси",
    "about-prog-2": "Автоматизація, події, бази даних",
    "about-prog-3": "Зрозуміла структура та код, що розширюється",
    "about-h-tg": "Telegram",
    "about-tg-1": "Боти як частина цілісної системи",
    "about-tg-2": "Зв'язка: бот + веб-інтерфейс + БД",
    "about-tg-3": "Моніторинг та управління в реальному часі",
    "about-h-val": "Цінності",
    "about-val-1": "Чесність та прямолінійність",
    "about-val-2": "Спокійний, робочий діалог",
    "about-val-3": "Продуманий стиль у коді та інтерфейсі",
    "tech-title": "Стек технологій",
    "flow-title": "Як я працюю",
    "flow-1-title": "Аналіз",
    "flow-1-desc": "Глибоке розуміння мети.",
    "flow-2-title": "Архітектура",
    "flow-2-desc": "Проєктування логіки.",
    "flow-3-title": "Реалізація",
    "flow-3-desc": "Написання чистого коду.",
    "flow-4-title": "Тестування",
    "flow-4-desc": "Забезпечення стабільності.",
    "flow-5-title": "Підтримка",
    "flow-5-desc": "Довгострокова надійність.",
    "proj-title": "Проєкти", 
    "proj-badge": "1 активний", 
    "proj-name": "Giveaway Bot & Панель адміна", 
    "proj-status": "В активній розробці", 
    "proj-more": "Детальніше", 
    "proj-tech-stack": "Стек: Python, Aiogram, SQLite",
    "proj-desc-1": "Автоматизована система управління конкурсами з адмін-панеллю та аналітикою.",
    "cont-title": "Контакти",
    "cont-note-text": "Якщо кнопки для зв'язку не працюють на вашому пристрої, ось мої прямі контактні дані:",
    "cont-note-gh-label": "GitHub:",
    "cont-note-mail-label": "Gmail:",
    "pa-back": "← Назад до проєктів",
    "pa-eyebrow": "Кейс-стаді",
    "pa-tagline": "Інтегрована система керування акаунтами Telegram: адмін-панель на сайті, автоматизований бот, контроль доступу та аналітика в одному продукті.",
    "pa-status": "В активній розробці",
    "pa-read-more": "Читати далі",
    "pa-read-less": "Згорнути",
    "pa-problem-title": "Проблема",
    "pa-problem-text": "Керування багатьма акаунтами Telegram для розіграшів вручну є неефективним і схильним до помилок. Користувачам потрібна анонімність, а адміністраторам — централізований контроль і прозорість без прямого доступу до особистих даних." ,
    "pa-solution-title": "Рішення",
    "pa-solution-text": "Я створив комплексну систему, що складається з Telegram-бота для автоматизованих дій, веб-панелі адміністратора для управління та захищеної бази даних. Система забезпечує безпечну участь у розіграшах та надає аналітику в реальному часі.",
    "pa-arch-text": "Бот → Бекенд → База даних → Адмін-панель",
    "pa-features-title": "Функціонал",
    "pa-feat-1": "Рольова система: Гнучке керування доступом.",
    "pa-feat-2": "Контроль доступу: Безпечний вхід та авторизація.",
    "pa-feat-3": "Логування: Детальна історія дій.",
    "pa-feat-4": "Логіка автоматизації: Розумні сценарії участі.",
    "pa-feat-5": "Моніторинг: Статус акаунтів у реальному часі.",
    "pa-concept-title": "Загальна концепція",
    "pa-concept-text": "Головна мета системи — автоматизувати участь акаунтів у розіграшах, забезпечити анонімність користувачів та надати адміністратору повний контроль через веб-інтерфейс. Архітектура є модульною та масштабованою: нові функції можна додавати без переробки всього коду.",
    "pa-users-title": "Користувачі та доступ",
    "pa-admin-h": "Для адміністратора",
    "pa-admin-li1": "Створення користувачів з ID, ім'ям та юзернеймом.",
    "pa-admin-li2": "Призначення прав, обмежень та рівнів доступу.",
    "pa-admin-li3": "Прив'язка одного або декількох акаунтів до користувача.",
    "pa-admin-li4": "Повний контроль доступу до функцій бота.",
    "pa-user-h": "Для користувача",
    "pa-user-li1": "Доступ до бота відкривається лише після активації через сайт.",
    "pa-user-li2": "Робота з декількома акаунтами під одним ID.",
    "pa-user-li3": "Перегляд статистики: участь, успішність, активність.",
    "pa-user-li4": "Безпечний сценарий роботи з кодами та паролями.",
    "pa-bot-title": "Telegram бот",
    "pa-bot-li1": "Автоматично бере участь у розіграшах: підписки, капчі, скриптові дії.",
    "pa-bot-li2": "Відстежує активність акаунтів та виводить статистику користувачеві.",
    "pa-bot-li3": "Синхронізований із сайтом через БД: зміни в панелі миттєво впливають на бота.",
    "pa-bot-li4": "Асинхронна обробка дозволяє керувати багатьма акаунтами одночасно.",
    "pa-bot-li5": "В акціях беруть участь лише активні та авторизовані акаунти.",
    "pa-db-title": "База даних та адмін-панель",
    "pa-db-struct-h": "Структура БД",
    "pa-db-struct-p": "Користувачі, акаунти, статистика та логи. Стан зберігається при перезапуску, доступна аналітика та експорт.",
    "pa-db-manage-h": "Управління",
    "pa-db-manage-p": "Додавання, редагування та видалення користувачів/акаунтів, керування діями бота та доступом.",
    "pa-db-ui-h": "Інтерфейс",
    "pa-db-ui-p": "Таблиці, картки, фільтрація, візуалізація активності, ховер-ефекти та адаптивна навігація.",
    "pa-sec-title": "Безпека та анонімність",
    "pa-sec-li1": "Особисті дані приховані та доступні лише адміністратору.",
    "pa-sec-li2": "Доступ до акаунтів захищений кодами та паролями.",
    "pa-sec-li3": "Дії бота та адміністратора логуються без розкриття приватної інформації.",
    "pa-sec-li4": "Модульна архітектура знижує ризик помилок та вразливостей.",
    "pa-adv-title": "Ключеві переваги",
    "pa-adv-li1": "Централізоване управління користувачами та акаунтами.",
    "pa-adv-li2": "Автоматизація участі в розіграшах без рутинних ручних завдань.",
    "pa-adv-li3": "Детальна аналітика за акаунтами та користувачами.",
    "pa-adv-li4": "Безпека, анонімність та прозорість управління.",
    "pa-adv-li5": "Легке розширення та підключення нових модулів.",
    "pa-stack-title": "Технологічний стек",
    "pa-stack-py": "Логіка бота та серверна обробка",
    "pa-stack-tg": "Взаємодія з користувачами",
    "pa-stack-web": "Веб-інтерфейс та UX",
    "pa-stack-db": "Зберігання користувачів та статистики",
    "pa-stack-async": "Асинхронна обробка декількох акаунтів",
    "pa-gallery-title": "Візуальна галерея",
    "pa-gal-cap1": "Панель управління адміністратора: доступ, ролі, контроль дій.",
    "pa-gal-cap2": "Шлях користувача: взаємодія в Telegram та сценарії участі.",
    "pa-gal-cap3": "Інфраструктура: стабільність, зберігання даних та масштабованість.",
    "pa-res-title": "Результат",
    "pa-res-text": "Це не просто бот, а повноцінна система: кожна дія під контролем, кожен акаунт захищений, а адміністратор бачить повну картину в реальному часі. Рішення підходить для масштабованої автоматизації, модульної розробки та прозорого управління акаунтами Telegram.",
    "pa-hide-details": "Приховати деталі",
    "pa-nav-arch": "Архітектура",
    "pa-nav-feat": "Функціонал",
    "pa-nav-users": "Користувачі",
    "pa-nav-bot": "Бот",
    "pa-nav-db": "База даних",
    "pa-nav-sec": "Безпека",
    "pa-nav-stack": "Стек",
    "pa-nav-gal": "Галерея",
    "pa-nav-res": "Результат",

    "python": {
        "tech-page-title": "Python: Фундаментальний розбір екосистеми",
        "tech-main-desc": "Python — це високорівнева мова, що поєднує неймовірну читабельність із потужними низькорівневими можливостями. Його архітектура побудована навколо віртуальної машини CPython, яка виконує скомпільований байт-код, що робить його ідеальним інструментом для автоматизації та бекенду.",
        "tech-deep-title": "Архітектура та внутрішні механізми",
        "tech-card-1-title": "Середовище CPython",
        "tech-card-1-text": "Розбір роботи віртуальної машини, інтерпретації байт-коду та стекової архітектури.",
        "tech-card-2-title": "Менеджмент ресурсів",
        "tech-card-2-text": "Глибоке управління пам'яттю через підрахунок посилань та евристичний збирач сміття.",
        "tech-card-3-title": "Асинхронність",
        "tech-card-3-text": "Модель кооперативної багатозадачності на основі asyncio для високонавантажених систем.",
        "full-sec-1-title": "1. Життєвий цикл коду: від .py до процесора",
        "full-sec-1-text": "Коли ви запускаєте скрипт, Python спочатку транслює його в байт-код — набір низькорівневих інструкцій. Віртуальна машина CPython послідовно виконує їх, що забезпечує крос-платформеність. Однак, на відміну від Java, Python інтерпретує байт-код динамічно, що дає гнучкість у зміні типів змінних під час виконання (Runtime). Це дозволяє писати лаконічний код, який легко масштабувати під будь-які бізнес-завдання.",
        "full-sec-2-title": "2. Управління пам'яттю та проблема GIL",
        "full-sec-2-text": "У Python основний механізм очищення пам'яті — підрахунок посилань (Reference Counting): об'єкт видаляється, щойно на нього перестають посилатися. Для циклічних посилань використовується збирач сміття (Garbage Collector). Найважливіше обмеження — глобальне блокування інтерпретатора (GIL). Це м'ютекс, який захищає потокобезпеку даних, але обмежує паралельне виконання байт-коду в різних потоках. Для обходу цього у важких задачах ми використовуємо модуль multiprocessing або асинхронність.",
        "full-sec-project-case-title": "3. Застосування в проєкті: Реалізація та бібліотеки",
        "full-sec-project-case-text": "Як я вже згадував в основному розділі мого портфоліо, Python — мій ключовий інструмент. У цьому проєкті я використав його для побудови модульної архітектури бота. Щоб гарантувати чистоту даних, я застосував бібліотеку **Pydantic** для суворої валідації вхідних об'єктів. Вся бізнес-логіка розіграшів була винесена в окремі асинхронні сервіси, що дозволило ізолювати API Telegram від важких обчислень. Також для глибокого моніторингу стану системи була впроваджена бібліотека **Loguru**, що забезпечує детальне логування кожного кроку автоматизації."
    },
    "aiogram": {
        "tech-page-title": "Aiogram: Професійна розробка Telegram-інтерфейсів",
        "tech-main-desc": "Aiogram — це повністю асинхронний фреймворк, побудований на базі asyncio. Він спонукає розробника писати чистий, типізований та модульний код, використовуючи сучасні патерни веброзробки.",
        "tech-deep-title": "Системні компоненти",
        "tech-card-1-title": "Advanced Routing",
        "tech-card-1-text": "Багаторівнева система фільтрів та роутерів для керування потоками даних.",
        "tech-card-2-title": "Stateful Logic (FSM)",
        "tech-card-2-text": "Реалізація користувацьких шляхів через збереження станів у Redis або RAM.",
        "tech-card-3-title": "Middlewares",
        "tech-card-3-text": "Шари проміжної обробки для впровадження наскрізної логіки (логування, анти-спам).",
        "full-sec-1-title": "1. Обробка подій та Middleware",
        "full-sec-1-text": "У Aiogram кожна подія (Update) проходить через ланцюжок Middlewares. Це дозволяє впроваджувати логіку до того, як повідомлення потрапить до основного обробника (handler). Наприклад, можна автоматично перевіряти підписку користувача на канал або обмежувати частоту запитів (Rate limiting). Це робить систему захищеною від зловживань і дозволяє винести спільну логіку в окремі шари, не захаращуючи код обробки команд.",
        "full-sec-2-title": "2. Машина станів (FSM)",
        "full-sec-2-text": "Для створення складних інтерфейсів використовується Finite State Machine. Вона пам'ятає, на якому етапі діалогу знаходиться користувач. Щоб дані не губилися при перезавантаженні бота, ми підключаємо зовнішні сховища (Redis/Postgres). Це стандарт для Enterprise-рішень, що дозволяє безшовно оновлювати код бота, не перериваючи активні сесії користувачів.",
        "full-sec-project-case-title": "Застосування в проєкті: Механіки Telegram",
        "full-sec-project-case-text": "Як я вже згадував на головній сторінці портфоліо, я спеціалізуюся на розробці Telegram-систем. У цьому проєкті я використав **Aiogram 3.x**, щоб побудувати асинхронну архітектуру взаємодії. Я реалізував систему **Custom Middlewares** для автоматичної перевірки підписки користувача на канали-спонсори перед допуском до розіграшу. Також було впроваджено машину станів (**FSM**) зі сховищем у **Redis**, що дозволило адміністраторам налаштовувати розіграші покроково (завантаження медіа, вибір дати, налаштування умов), не втрачаючи прогрес навіть при перезавантаженні сервера. Для захисту від накруток я інтегрував кастомні фільтри на стороні диспетчера, які відсікають підозрілі дії ботів."
    },
    "postgres": {
        "tech-page-title": "PostgreSQL: База даних промислового рівня",
        "tech-main-desc": "PostgreSQL — це об'єктно-реляційна СУБД, відома своєю надійністю, підтримкою складних запитів і суворим дотриманням стандартів ACID.",
        "tech-deep-title": "Технічні деталі",
        "tech-card-1-title": "MVCC",
        "tech-card-1-text": "Багатоверсійність дозволяє читати дані без блокувань під час їх запису.",
        "tech-card-2-title": "ACID Compliance",
        "tech-card-2-text": "Гарантія збереження даних навіть при раптових збоях живлення або системи.",
        "tech-card-3-title": "JSONB Support",
        "tech-card-3-text": "Ефективна робота з неструктурованими даними всередині SQL-таблиць.",
        "full-sec-1-title": "1. Транзакції та цілісність",
        "full-sec-1-text": "Postgres гарантує, що кожна операція або виконається повністю, або не виконається взагалі (атомарність). Механізм Write-Ahead Logging (WAL) записує всі зміни в журнал перед їх внесенням до таблиці. Це критично важливо для фінансових або ігрових систем, де помилка в одному записі може призвести до втрати консистентності всієї бази даних.",
        "full-sec-2-title": "2. Індексація та пошук",
        "full-sec-2-text": "Ми використовуємо не тільки стандартні B-tree індекси, але й GIN-індекси для прискорення пошуку по JSONB полях. Це дозволяє Postgres поєднувати швидкість NoSQL рішень із надійністю класичних реляційних баз. Правильне планування запитів (Explain Analyze) дозволяє оптимізувати навантаження та забезпечувати миттєвий відгук навіть на мільйонних вибірках.",
        "full-sec-project-case-title": "Застосування в проєкті: Архітектура даних",
        "full-sec-project-case-text": "Як я вже згадував на головній сторінці, я використовую бази даних для забезпечення максимальної стабільності систем. У цьому проєкті я обрав PostgreSQL через її розширюваність та надійність. Для інтеграції з асинхронним кодом бота я застосував **SQLAlchemy** у зв'язці з драйвером **asyncpg**, що дозволило базі даних працювати без блокувань основного потоку. Я спроєктував реляційну схему так, щоб навіть за участі 100,000+ осіб вибірка переможців відбувалася миттєво. Це було досягнуто за рахунок налаштування складених **B-tree індексів** за полями ідентифікаторів користувачів та розіграшів, що гарантує 100% консистентність даних при масових операціях."
    },
    "flask": {
        "tech-page-title": "Flask & FastAPI: Сучасні Web-інтерфейси",
        "tech-main-desc": "Мікрофреймворки для створення серверної логіки та API. Flask використовується для гнучких панелей керування, а FastAPI — для високопродуктивних асинхронних сервісів з автоматичною валідацією даних.",
        "tech-deep-title": "Основні можливості",
        "tech-card-1-title": "Microservices Design",
        "tech-card-1-text": "Архітектура без зайвого коду — підключайте тільки потрібні модулі для кожного завдання.",
        "tech-card-2-title": "Pydantic Validation",
        "tech-card-2-text": "У FastAPI дані перевіряються автоматично на рівні типів, виключаючи помилки запитів.",
        "tech-card-3-title": "Swagger & OpenAPI",
        "tech-card-3-text": "Автоматична інтерактивна документація API доступна відразу 'з коробки'.",
        "full-sec-1-title": "1. RESTful API та Dependency Injection",
        "full-sec-1-text": "При проєктуванні бекенду я дотримуюся принципів REST. Кожному ресурсу відповідає свій URL, а дії визначаються стандартними HTTP-методами. У FastAPI реалізована потужна система впровадження залежностей (DI). Це дозволяє легко керувати підключеннями до бази даних, автентифікацією та налаштуваннями, роблячи код модульним і придатним для автоматичного тестування. Весь обмін даними відбувається у форматі JSON, що забезпечує ідеальну сумісність із будь-якими фронтенд-фреймворками.",
        "full-sec-2-title": "2. Шаблонізація та асинхронний I/O",
        "full-sec-2-text": "Для Flask ми використовуємо Jinja2 — безпечний рушій шаблонів. Він дозволяє динамічно генерувати HTML на сервері, вставляючи дані з Python прямо в розмітку. У випадку з FastAPI використовується повністю асинхронний ввід-вивід. Це означає, що сервер не 'засинає' під час довгого запиту до бази даних, а продовжує обробляти інші вхідні виклики. Це критично важливо для панелей моніторингу, де дані повинні оновлюватися миттєво."
    },
    "git": {
        "tech-page-title": "Git: Професійний контроль версій",
        "tech-main-desc": "Git — це розподілена система контролю версій, яка є стандартом індустрії. Вона дозволяє зберігати історію змін, працювати в команді та проводити безпечні експерименти з кодом.",
        "tech-deep-title": "Основні концепції",
        "tech-card-1-title": "Branching Strategy",
        "tech-card-1-text": "Створення ізольованих гілок для кожної нової функції (Feature-driven development).",
        "tech-card-2-title": "Snapshot Model",
        "tech-card-2-text": "Git зберігає не відмінності у файлах, а повні знімки стану проєкту для надійності.",
        "tech-card-3-title": "Atomic Commits",
        "tech-card-3-text": "Можливість розбивати зміни на логічні частини для легкого відкату та аналізу.",
        "full-sec-1-title": "1. Внутрішня будова: Знімки та Хеші",
        "full-sec-1-text": "Git — це по суті графова база даних. Кожен коміт має унікальний SHA-1 хеш, який гарантує, що вміст коду не було змінено непомітно. На відміну від старих систем (SVN), Git зберігає повні знімки (snapshots) файлів. Це робить операції перемикання між гілками (checkout) та злиття (merge) миттєвими. Розуміння таких концептів, як 'індекс' (staging area) та 'дерево' (tree), дозволяє мені ефективно керувати навіть найскладнішими конфліктами при злитті коду.",
        "full-sec-2-title": "2. Методологія Git Flow",
        "full-sec-2-text": "Для стабільної розробки я використовую Git Flow. Основна гілка (main) завжди містить тільки протестований, робочий код. Розробка ведеться в гілці 'develop', а кожна нова функція створюється в окремій гілці 'feature/'. Це виключає ситуацію, коли недописаний код ламає працюючу систему. Використання команд cherry-pick та rebase дозволяє підтримувати історію комітів чистою та зрозумілою, що критично для довгострокової підтримки проєкту."
    },
    "frontend": {
        "tech-page-title": "HTML / CSS / JS: Візуальний інтерфейс",
        "tech-main-desc": "Трійка технологій, що формує користувацький досвід. Ми використовуємо сучасні стандарти розмітки, стилів та скриптів для створення швидких і чуйних вебзастосунків.",
        "tech-deep-title": "Основні технології",
        "tech-card-1-title": "Modern Layouts",
        "tech-card-1-text": "Верстка на Flexbox та Grid для ідеального відображення на будь-яких типах пристроїв.",
        "tech-card-2-title": "ES6+ Standards",
        "tech-card-2-text": "Використання асинхронності та модулів у JS для плавної роботи інтерфейсу.",
        "tech-card-3-title": "UX / UI Design",
        "tech-card-3-text": "Акцент на інтуїтивність, доступність та сучасні візуальні ефекти (Glassmorphism).",
        "full-sec-1-title": "1. DOM та асинхронний JavaScript",
        "full-sec-1-text": "Сучасний фронтенд — це не просто статичні сторінки. За допомогою JavaScript я маніпулюю деревом DOM (Document Object Model), динамічно змінюючи інтерфейс у відповідь на дії користувача. Використання API Fetch дозволяє обмінюватися даними з бекендом у фоновому режимі. Це створює ефект Single Page Application (SPA), коли сторінка не перезавантажується повністю, а лише плавно оновлює потрібні блоки даних, що значно підвищує комфорт користувача.",
        "full-sec-2-title": "2. CSS Архітектура та Анімації",
        "full-sec-2-text": "Для стилізації я використовую CSS-змінні (Variables) та сучасні методи позиціонування. Це дозволяє легко впроваджувати темні та світлі теми. Анімації реалізовані за допомогою апаратного прискорення (transform: translate3d), що гарантує плавність 60 FPS навіть на мобільних пристроях. Особлива увага приділяється методології верстки: я розділяю стилі на логічні модулі, щоб їх було легко перевикористовувати в різних частинах проєкту.",
        "full-sec-project-case-title": "Застосування в проєкті: Інтерактивний інтерфейс",
        "full-sec-project-case-text": "Як я вже згадував на головній сторінці портфоліо, я приділяю велику увагу не тільки коду, але й візуальному комфорту користувача. У цьому проєкті я реалізував адаптивну панель керування на чистому **JavaScript** без використання важких фреймворків, що забезпечило миттєве завантаження. Я застосував сучасні методи верстки (Flexbox та CSS Grid) для створення складного 'скляного' інтерфейсу (Glassmorphism), який зберігає читабельність на будь-яких пристроях. Вся комунікація з бекендом відбувається через асинхронні запити **Fetch API**, що дозволило адміністратору керувати розіграшами та відстежувати статистику учасників без жодного перезавантаження сторінки."
    },
    "asyncio": {
        "tech-page-title": "Asyncio: Глибока асинхронність у Python",
        "tech-main-desc": "Asyncio — це бібліотека для написання конкурентного коду з використанням синтаксису async/await. Це фундамент для сучасних високонавантажених систем, що працюють з тисячами мережевих з'єднань одночасно.",
        "tech-deep-title": "Концепції асинхронності",
        "tech-card-1-title": "Event Loop",
        "tech-card-1-text": "Цикл подій, який керує виконанням усіх завдань в одному потоці.",
        "tech-card-2-title": "Coroutines",
        "tech-card-2-text": "Функції, які можуть призупиняти роботу, не блокуючи всю програму.",
        "tech-card-3-title": "Non-blocking I/O",
        "tech-card-3-text": "Система не чекає відповіді від мережі, а миттєво перемикається на інші завдання.",
        "full-sec-1-title": "1. Кооперативна багатозадачність",
        "full-sec-1-text": "На відміну від класичних потоків (Threads), Asyncio використовує модель, де корутини самі повертають управління назад у Event Loop. Це виключає виникнення 'стану гонки' (race conditions) при роботі зі спільними даними і дозволяє одному процесу обслуговувати колосальну кількість запитів, споживаючи в десятки разів менше оперативної пам'яті. Це робить Python ідеальним для мікросервісів та ботів.",
        "full-sec-2-title": "2. Масштабованість мережевих викликів",
        "full-sec-2-text": "Asyncio працює на низькорівневих системних викликах (epoll/kqueue), що дозволяє йому стежити за станом тисяч сокетів. Програма 'засинає' на рівні ядра ОС до тих пір, поки дані не надійдуть у буфер. Завдяки цьому, затримка (latency) одного запиту не впливає на загальну пропускну здатність всієї системи.",
        "full-sec-project-case-title": "Застосування в проєкті: Мультиаккаунтинг і Швидкість",
        "full-sec-project-case-text": "**Про Asyncio я не згадував на головній сторінці**, але в цьому проєкті дана технологія стала ключовою. Я використав асинхронність для реалізації **мультиаккаунтингу** — бот може одночасно працювати з різними сесіями Telegram, не заважаючи одна одній. Використовуючи метод `asyncio.gather()`, я налаштував паралельну перевірку підписок користувачів у 5-10 каналах одночасно. Це дозволило скоротити час очікування для користувача з кількох секунд до мілісекунд. Також асинхронні черги (Tasks) забезпечили стабільну роботу фонових розсилок, які не сповільнюють основний інтерфейс бота під час активних розіграшів."
    }
}